target C {
    workers: 2,
    keepalive: true,
    files: [
        "/lib/c/reactor-c/util/sensor_simulator.c", 
        "/lib/c/reactor-c/util/sensor_simulator.h",
    ],
    cmake-include: [
        "/lib/c/reactor-c/util/sensor_simulator.cmake"
    ],
    build-type: RelWithDebInfo // Release with debug info
}
preamble {=
    #include "sensor_simulator.h"
    char* messages[] = {"Cutter Simulator"};
    int num_messages = 1;
=}
reactor ButtonController(
    key:char('\0'),
    description:string("Button")
) {
    physical action pushed:char*;
    output push:bool;
    timer t(1 ms); // Give time for the startup in main to have occurred.
    reaction(t) -> pushed {=
        register_sensor_key(self->key, pushed);
        if (self->key == '\0') {
            lf_print("%s with any key", self->description);
        } else {
            lf_print("%s with '%c'", self->description, self->key);
        }
    =}
    reaction(pushed) -> push {=
        lf_set(push, true);
    =}
}
reactor MachineController {
    input emergencyStop:bool;
    input run:bool;
    initial mode Off {
        reaction(run) -> reset(Running) {=
            lf_set_mode(Running);
        =}
    }
    mode Running {
        timer t(0, 100 msec);
        reaction(emergencyStop) -> Off {=
            if (emergencyStop) lf_set_mode(Off);
        =} deadline (1 msec) {=
            lf_print("DEADLINE VIOLATION!");
            lf_set_mode(Off);
        =}
        // With centralized coordination, time cannot advance to trigger
        // this reaction unless null messages have arrived on emergencyStop.
        reaction(t) -> Off {=
            show_tick("*");
        =} deadline (10 msec) {=
            lf_set_mode(Off);
        =}
    }
}
main reactor {
    eStop = new ButtonController(key = 'e', description="Emergency stop");
    run = new ButtonController(key = 'r', description="Run");
    m = new MachineController();
    
    eStop.push -> m.emergencyStop;
    run.push -> m.run;
    
    physical action stop:char*;
    
    reaction(startup) -> stop {=
        // This has to be done exactly once.
        start_sensor_simulator(messages, num_messages, 16, NULL, LOG_LEVEL_INFO);
        register_sensor_key('x', stop);
        lf_print("Exit with 'x'");
    =}
    reaction(stop) {=
        lf_request_stop();
    =}
}