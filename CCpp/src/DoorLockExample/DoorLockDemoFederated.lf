/**
 * DoorLockDemoFederated.lf implements federated version of car door lock system with a single door with user controls, 
 * a controller, and a lock actuator to lock/unlock the door. The system can be controller using 3 modes.
 * 1. Buttons on the physical door , 2. External System (Like an RFID Key Fob), 3. Mobile Key via cloud service
 * See README for sample specification
 * 
 * NOTE: To be able to interact in federated mode, make the following changes to the generated 
 * `DoorLockDemoFederated` script in bin directory
 *      Move this block: 
 *          ``echo "#### Launching the federate ui."
 *          /Users/ra/git/examples-lingua-franca/CCpp/bin/DoorLockDemoFederated_ui -i $FEDERATION_ID &
 *          pids[3]=$!``
 *      after 
 *          ``echo "#### Bringing the RTI back to foreground so it can receive Control-C."``
 *      Make sure to remove trailing `&` on
 *          ``/Users/ra/git/examples-lingua-franca/CCpp/bin/DoorLockDemoFederated_ui -i $FEDERATION_ID``
 *
 * @author Ravi Akella
 */

target CCpp{
    keepalive: true,
    files: "include/types.hpp",
    coordination: decentralized
};

preamble {=
    #include "types.hpp"
    #include <iostream>
    #include <string.h>
=}

reactor UserInteraction{
    output key_fob:char;
    output key_mobile:char;
    output door_control:char;
    output door_lock_button:char;
    
    physical action key_press:char;
    
    preamble {= 
        void* read_input(void* user_response) {
            std::cout << "***************************************************************"
                        << std::endl;
            std::cout << "Press <key> and hit return or enter to execute <action>"
                        << std::endl;
            std::cout << "'o' - OPEN the door"
                        << std::endl;
            std::cout << "'c' - CLOSE the door"
                        << std::endl;
            std::cout << "'l' - LOCK using door key"
                        << std::endl;
            std::cout << "'u' - UNLOCK using door key"
                        << std::endl;
            std::cout << "'f' - LOCK using key fob"
                        << std::endl;
            std::cout << "'r' - UNLOCK using key fob"
                        << std::endl;
            std::cout << "'m' - LOCK using mobile key"
                        << std::endl;
            std::cout << "'n' - UNLOCK using mobile key"
                        << std::endl;
            int c;
            while(1) {
                while((c = getchar()) != '\n') {
                    lf_schedule_copy(user_response, 0, &c, 1);
                    if (c == EOF) break;
                }
    
                if (c == EOF) break;
            }
            return NULL;
         }
    =}
    
    reaction(startup) -> key_press {=
        // start new thread
        lf_thread_t thread_id;
        lf_thread_create(&thread_id, &read_input, key_press);
    =}
    reaction(key_press)->key_fob, door_control, door_lock_button, key_mobile{=
        char key = key_press->value;
        if (key == 'f' || key == 'r'){
            SET(key_fob, key);
        }
        else if(key == 'o' || key == 'c'){
            SET(door_control, key);
        }
        else if(key == 'l' || key == 'u'){
            SET(door_lock_button, key);
        }
        else if(key == 'm' || key == 'n'){
            SET(key_mobile, key);
        }
        else{
            //Unassigned buttons
        }
    =}
}

reactor CloudAuth(auth_delay:time(50 msec)){
    //TODO: Make this a MQTT cloud node
    //Other possibilities: grpc
    input app_in:LockCommandStruct;
    output app_auth_out:LockCommandStruct;
    state authenticated:int(0); //0-none requested, 1-success, 2-failed
    state counter:int(0); //For every 5 successful attempts, throw one failed
    state lock_command:LockCommandStruct({={LockCommandStruct::LOCK,lf_time_logical()}=}); 
    
    logical action auth;
    reaction(app_in)->auth{=
        if((self->counter)%5 == 1)
            self->authenticated = 2;
        else{
             self->counter++;
             self->authenticated = 1;
        }
        
        self->lock_command.lc = app_in->value.lc;
        self->lock_command.ts = app_in->value.ts;
  
        lf_schedule(auth, self->auth_delay);
    =}
    
    reaction(auth)->app_auth_out{=
        app_auth_out->value.lc = self->lock_command.lc;
        app_auth_out->value.ts = self->lock_command.ts;
        SET_PRESENT(app_auth_out);
    =}
}

reactor MobileKey(min_delay:time(200 msec)){    
    input userInput:char;
    output lock:LockCommandStruct;
    
    reaction(userInput)->lock {=
        
        char key = userInput->value;
        lock->value.ts = lf_time_physical();
        
        if (key == 'm'){
            lock->value.lc = LockCommandStruct::LOCK;
            lf_nanosleep((rand()%10+1) * self->min_delay); //Simulate wireless propagation delay
            SET_PRESENT(lock);
        }
        else if(key == 'n'){
            lock->value.lc = LockCommandStruct::UNLOCK;
            lf_nanosleep((rand()%10+1) * self->min_delay); //Simulate wireless propagation delay
            SET_PRESENT(lock);
        }
        else{
            //Do nothing
            lf_print("Unknown key @ MobileKey\n");
        }
    =}
}

reactor ExternalSystem(min_delay:time(100 msec)){
   
    input userInput:char;
    output lock:LockCommandStruct;
    
    reaction(userInput)->lock {=
        
        char key = userInput->value;
        lock->value.ts = lf_time_physical();

        if (key == 'f'){
            lock->value.lc = LockCommandStruct::LOCK;
            lf_nanosleep((rand()%10+1) * self->min_delay); //Simulate Radio propagation delay
            SET_PRESENT(lock);
        }
        else if(key == 'r'){
            lock->value.lc = LockCommandStruct::UNLOCK;
            lf_nanosleep((rand()%10+1) * self->min_delay); //Simulate Radio propagation delay
            SET_PRESENT(lock);
        }
        else{
            //Do nothing
            lf_print("Unknown key @ ExternalSystem\n");
        }
    =}
}

reactor DoorLockButton{
    state lock_status:LockCommandStruct({={LockCommandStruct::LOCK,lf_time_logical()}=});
    output out:LockCommandStruct;
    input userInput:char;
    
    reaction(userInput)->out{=
        char key = userInput->value;
        out->value.ts = lf_time_physical();
        
        if (key == 'l'){
            self->lock_status.lc = LockCommandStruct::LOCK;
            out->value.lc = self->lock_status.lc;
            SET_PRESENT(out);
        }
        else if(key == 'u'){
            self->lock_status.lc = LockCommandStruct::UNLOCK;
            out->value.lc = self->lock_status.lc;
            SET_PRESENT(out);
        }
        else{
            //Do nothing
            lf_print("Unknown key @ DoorLockButton\n");
        }
    =}
}

reactor DoorSensor{
    state door_status:OpenEventStruct({={OpenEventStruct::OPEN,lf_time_logical()}=});
    input userInput:char;
    output out:OpenEventStruct;

    reaction(userInput)->out{=
        char key = userInput->value;
        out->value.ts = lf_time_physical();
        
        if (key == 'o'){
            self->door_status.oe = OpenEventStruct::OPEN;
            out->value.oe = self->door_status.oe;
            SET_PRESENT(out);
        }
        else if(key == 'c'){
            self->door_status.oe = OpenEventStruct::CLOSE;
            out->value.oe = self->door_status.oe;
            SET_PRESENT(out);
        }
        else{
            //Do nothing
            lf_print("Unknown key @ DoorSensor\n");
        }
    =}
    
}

reactor DoorLockController{
    
    state door_sensor_state:OpenEventStruct;
    state lock_state:LockEventStruct;
    
    input in1:LockCommandStruct; //from external system 
    input in4:LockCommandStruct; //from mobile key
    input in2:OpenEventStruct;
    input in3:LockCommandStruct; //from car door
    
    output out1:LockCommandStruct; 
    output out2:OpenEventStruct;
    output out3:LockEventStruct;   
      
    reaction(in1)->out1{=
        auto& s = in1->value;
        std::string command_string = (s.lc==LockCommandStruct::LOCK) ? "LOCK" : "UNLOCK"; 
        //std::cout << lf_time_physical() << ": Lock Status: "<< command_string << std::endl;
        
        //Send command to actuator only when the door is closed
        if(self->door_sensor_state.oe == OpenEventStruct::CLOSE){
            out1->value.lc = s.lc;
            out1->value.ts = s.ts;
            SET_PRESENT(out1);
        }
        else{
           //Ignore press
           std::cout << lf_time_physical() << ": External command '"<< command_string 
                        << "' cannot be applied when door is open." << std::endl;
        }
    =}
    
    reaction(in4)->out1{=
        auto& s = in4->value;
        std::string command_string = (s.lc==LockCommandStruct::LOCK) ? "LOCK" : "UNLOCK"; 
        //std::cout << lf_time_physical() << ": Lock Status: "<< command_string << std::endl;
        
        //Send command to actuator only when the door is closed
        if(self->door_sensor_state.oe == OpenEventStruct::CLOSE){
            out1->value.lc = s.lc;
            out1->value.ts = s.ts;
            SET_PRESENT(out1);
        }
        else{
           //Ignore press
           std::cout << lf_time_physical() << ": External command '"<< command_string 
                        << "' cannot be applied when door is open." << std::endl;
        }
    =}
    
    reaction(in2)->out2{=
        auto& s = in2->value;
        self->door_sensor_state.oe = s.oe; //update door state
        
        //Don't allow "open" when door is locked.
        if(s.oe == OpenEventStruct::OPEN && self->lock_state.le == LockEventStruct::LOCKED){
            std::cout << lf_time_physical() <<": Door cannot be opened when locked." << std::endl;
            self->door_sensor_state.oe = OpenEventStruct::CLOSE;
        }
        
        //Either way, update timestamp
        self->door_sensor_state.ts = lf_time_logical();
        
        out2->value.oe = self->door_sensor_state.oe;
        out2->value.ts = self->door_sensor_state.ts;
        SET_PRESENT(out2);
    =}
    
    reaction(in3)->out1, out3{=
        auto& s = in3->value;
        
        //lock-unlock only works when the door is closed
        if(self->door_sensor_state.oe == OpenEventStruct::CLOSE){
            
            if(s.lc == LockCommandStruct::LOCK)
                self->lock_state.le = LockEventStruct::LOCKED;
            else 
                self->lock_state.le = LockEventStruct::UNLOCKED;
                
            self->lock_state.ts = lf_time_logical();
            
            out1->value.lc = s.lc;
            out1->value.ts = s.ts;
            SET_PRESENT(out1); //send to the actuator
            
            out3->value.le = self->lock_state.le;
            out3->value.ts = self->lock_state.ts;
            SET_PRESENT(out3); //Status to display
        }
        else{
           //Ignore press
           std::string command_string = (s.lc==LockCommandStruct::LOCK) ? "LOCK" : "UNLOCK"; 
           std::cout << lf_time_physical() << ": Command '"<< command_string << "' cannot be applied when door is open." << std::endl;
        }
    =}
}

reactor DoorLockActuator(tolerance:time(1000 msec)){
    preamble {=
        #include <thread>
    =}
    
    input in:LockCommandStruct;
    physical action actuate:LockCommandStruct;
    
    reaction(in)->actuate{=
        lf_schedule_copy(actuate, MSEC(300), &(in->value), 1);
    =}
    
    reaction(actuate){=
        std::string command_string = (actuate->value.lc==LockCommandStruct::LOCK) ? "LOCK" : "UNLOCK";
        
        //physical time diff between button press time and receive time (assuming clock sync)
        interval_t delta = (lf_time_physical() - actuate->value.ts); 
        if(delta > self->tolerance){
            std::cout << lf_time_physical() << ": Deadline violated!! " << command_string 
                  << " executed " <<  delta-self->tolerance << " nsecs later then expected." << std::endl;
            std::cout << "\t Probable trigger: min_delay parameter on ExternalSystem reactor if using key fob." << std::endl;
            std::cout << "\t Probable trigger: min_delay and auth_delay parameters on MobileKey and CloudAuth reactors\n"
                      << "\t respectively if using mobile key." << std::endl;      
        }
        else{
            std::cout << lf_time_physical() << ": Command " << command_string 
                    << " executed successfully. (time diff: " <<  delta << " nsecs)"
                    << std::endl;
        }
        
    =} STP(tolerance){= /* NOTE: This does not capture the requirement that actuation should occur within 1 sec of button press */
        std::cout << lf_time_physical() <<": deadline violation." << std::endl;
    =}
}

reactor DoorLockSystem{
    
    //Interface definition
    output open_event:OpenEventStruct;
    output lock_event:LockEventStruct;
    input lock_fob:LockCommandStruct;
    input lock_mobile:LockCommandStruct;
    input door_control:char;
    input door_lock_button:char;
    
    controller = new DoorLockController();
    sensor = new DoorSensor();
    button = new DoorLockButton();
    door_actuator = new DoorLockActuator();
        
    lock_fob->controller.in1;
    lock_mobile->controller.in4;
    
    button.out -> controller.in3;
    sensor.out -> controller.in2;
    door_control->sensor.userInput;
    door_lock_button->button.userInput;
    
    controller.out1 -> door_actuator.in;
    controller.out2 -> open_event;
    controller.out3 -> lock_event;
}

reactor Display{
    input open_event:OpenEventStruct;
    input lock_event:LockEventStruct;
    
    reaction(open_event){=
        auto& s = open_event->value;
        std::string oe_string = (s.oe==OpenEventStruct::OPEN) ? "OPEN" : "CLOSE"; 
        std::cout << lf_time_physical() << ": Door Status: "<< oe_string << std::endl;
    =}
    
    reaction(lock_event){=
        auto& s = lock_event->value;
        std::string le_string = (s.le==LockEventStruct::LOCKED) ? "LOCKED" : "UNLOCKED"; 
        std::cout << lf_time_physical() << ": Lock Status: "<< le_string << std::endl;
    =}
}

federated reactor{
 
  dls = new DoorLockSystem();
  es = new ExternalSystem();
  d = new Display();
  
  es.lock->dls.lock_fob;
  
  dls.open_event -> d.open_event;
  dls.lock_event -> d.lock_event;
  
  ui = new UserInteraction();
  ui.key_fob -> es.userInput;
  ui.door_control -> dls.door_control;
  ui.door_lock_button -> dls.door_lock_button;
  
  ca = new CloudAuth();
  mk = new MobileKey();
  ui.key_mobile -> mk.userInput;
  mk.lock -> ca.app_in;
  ca.app_auth_out -> dls.lock_mobile;
}
