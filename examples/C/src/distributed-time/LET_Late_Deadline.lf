/**
 * This example shows a classic sensor-processor-actuator system. The `after` delays on the
 * connections provide a system-level Logical Execution Time (LET). If these delays are large enough
 * to absorb upstream processing times and communication latencies, then the default STA of zero is
 * safe. In these cases, it is safe anyway because the Processor and Actuator have no other inputs
 * or events (clocks or actions), and hence will not attempt to advance logical time unless an input
 * arrives.
 *
 * However, this example has a flaw that may make it unacceptable in practice: the Processor, on
 * every second firing, takes 50ms to process the data, which causes a violation of the deadline at
 * the Actuator. The problem, however, is that the deadline handler is not invoked until the input
 * actually arrives. This may be too late for the application, which may need to respond to such a
 * deadline violation sooner. This is fixed in LET_Deadline_STA.lf.
 *
 * @author Edward A. Lee
 */
target C {
  coordination: decentralized,
  timeout: 1 s,
  workers: 8
}

reactor Sensor {
  output out: int
  timer t(0, 100 ms)
  state counter: int = 0

  @label("10 ms delay")
  reaction(t) -> out {=
    self->counter++;
    lf_sleep(MSEC(10));
    lf_set(out, self->counter);
    lf_print("Sensor1 " PRINTF_TIME ": Sensing... (counter=%d)",
        lf_time_logical_elapsed(), self->counter);
  =}
}

reactor Processor {
  input in: int
  output out: int
  state counter: int = 0

  @label("10 or 50 ms delay")
  reaction(in) -> out {=
    if (self->counter % 2 == 0) {
        lf_print("Processor1 " PRINTF_TIME " : Normal processing(10ms)... (in=%d)",
            lf_time_logical_elapsed(), in->value);
        lf_sleep(MSEC(10));
    } else {
        lf_print("Processor1 " PRINTF_TIME ": Excessive delay processing(50ms)... (in=%d)",
            lf_time_logical_elapsed(), in->value);
        lf_sleep(MSEC(50));
    }
    lf_set(out, in->value);
    self->counter++;
  =}
}

reactor Actuator(STA: time = 0) {
  input in: int
  state data_arrived: bool = false

  @label("normal")
  reaction(in) {=
    lf_print("Actuator1 " PRINTF_TIME ": Actuating with sensor value (in=%d) at physical time " PRINTF_TIME,
        lf_time_logical_elapsed(), in->value, lf_time_physical_elapsed());
    self->data_arrived = true;
  =} deadline(5 ms) {=
    lf_print("Actuator1 " PRINTF_TIME ": *** Deadline missed on sensor data (in=%d) at physical time " PRINTF_TIME " ***",
        lf_time_logical_elapsed(), in->value, lf_time_physical_elapsed());
  =}
}

federated reactor {
  a1_sensor = new Sensor()
  b1_processor = new Processor()
  c1_actuator = new Actuator()

  a1_sensor.out -> b1_processor.in after 15 ms
  b1_processor.out -> c1_actuator.in after 15 ms
}
