/**
 * The RandomDelay reactor simulates a physical connection with a random delay. The timestamp at the
 * receiving end is larger than the sender's timestamp by a random amount given by an exponential
 * random variable with
 */
target C {
  keepalive: true,
  build-type: debug
}

import WebSocketServerString from "../lib/WebSocketServerString.lf"
import Random from "../lib/Random.lf"

preamble {=
  #include <math.h>
  typedef struct complex_t {
    double real;
    double imaginary;
  } complex_t;
  typedef struct timestamped_complex_t {
    complex_t phasor;
    instant_t timestamp;
  } timestamped_complex_t;
=}

main reactor(n: int = 50) {
  s = new[n] PhaseMeasurementUnit(drift=0.1, period = 100 ms, faulty_index = 42)
  t = new[n] RandomDelay(average = 1 s)
  o = new Observer(n=n)
  s.phasor -> t.in
  t.out -> o.phasors
}

reactor RandomDelay(average: time = 1 sec, bank_index: int = 0) extends Random {
  input in: timestamped_complex_t
  output out: timestamped_complex_t
  logical action a: timestamped_complex_t

  reaction(startup) {=
    // Make sure each instance has a different seed.
    self->seed = (unsigned int) self->bank_index;
  =}

  reaction(a) -> out {=
    lf_set(out, a->value);
  =}

  reaction(in) -> a {=
    double lambda = SEC(1) / ((double)self->average);
    double exp = exponential(lambda);
    interval_t delay = (interval_t)llround(exp * (double)SEC(1));
    lf_schedule_copy(a, delay, &in->value, 1);
  =}
}

reactor PhaseMeasurementUnit(
    period: time = 100 ms,
    bank_index: int = 0,  // identifier
    faulty_index: int = -1,
    initial_phase: double = 0.0,
    // radians per second
    drift: double = 0.0) {
  output phasor: timestamped_complex_t
  timer t(0, period)
  state phase: double = initial_phase

  reaction(startup) {=
    // Give each instance a unique starting phase.
    self->phase = 0.1 * self->bank_index;
    if (self->bank_index == self->faulty_index) self->phase += 0.2;
  =}

  reaction(t) -> phasor {=
    complex_t reading;
    reading.real = cos(self->phase);
    reading.imaginary = sin(self->phase);
    timestamped_complex_t tc;
    tc.phasor = reading;
    tc.timestamp = lf_time_logical();
    lf_set(phasor, tc);
    self->phase += (self->drift * self->period) / SEC(1);
  =}
}

reactor Observer(
    // Number of inputs
    n: int = 2) {
  input[n] phasors: timestamped_complex_t
  state connected: bool = false

  w = new WebSocketServerString(
      initial_file = {= LF_SOURCE_DIRECTORY LF_FILE_SEPARATOR "Synchrophasors.html" =})

  reaction(phasors) -> w.in_dynamic {=
    char* json = (char*)malloc(sizeof(char) * (30 * (10 * self->n)));
    char* p = json; // pointer to next position to write.
    snprintf(p, 10, "{\"real\":[");
    p += 9;
    for (int n = 0; n < self->n; n++) {
      if (n != 0) {
        *p++ = ',';
        *p++ = ' ';
      }
      long int height = lround(phasors[n]->value.phasor.real * 100);
      int len = snprintf(p, 5, "%3ld", height);
      if (len > 0) p += len; // Excluding trailing null terminator.
    }
    snprintf(p, 16, "],\"imaginary\":[");
    p += 15;
    for (int n = 0; n < self->n; n++) {
      if (n != 0) {
        *p++ = ',';
        *p++ = ' ';
      }
      long int height = lround(phasors[n]->value.phasor.imaginary * 100);
      int len = snprintf(p, 5, "%3ld", height);
      if (len > 0) p += len; // Excluding trailing null terminator.
    }
    *p++ = ']';
    *p++ = '}';
    *p = '\0';
    if (self->connected) {
      lf_set(w.in_dynamic, json);
    }
    // lf_print("%s", json);
  =}

  reaction(w.connected) {=
    self->connected = w.connected->value;
  =}
}
