target C {
  files: ["../../lib/fault_tolerance_common.h"],
}

import TaskRetryTemplate, TaskBody, TaskRetryWorstCaseTemplate from "TaskRetryTemplate.lf"

import TaskRetryNoAdvance from "TaskRetryNoAdvanceTemplate.lf"

reactor TaskScheduler(period: time = 0 msec) {
  timer t(0, period)
  output trigger: int
  state total_tasks: int = 0

  reaction(startup) {=
    // Setup rand() function.
    // Fix seed.
    srand(16);
    // Seed 16 fails on failure_rate 1%. Around 6600.

    // Even using same seed, our approach differs with just re-executing because after task dropping they don't have same behavior..
  =}

  reaction(t) -> trigger{=
    lf_set(trigger, 0);
    self->total_tasks ++;
  =}

  reaction(shutdown) {=
    lf_print("Total_tasks: %d.", self->total_tasks - 1);
  =}
}

reactor Task1Body extends TaskBody {
  preamble {=
    #include <time.h>
    #include "fault_tolerance_common.h"

    int total_task1(int checkpoint) {
      const static double FAILURE_RATE = 0.005; // 0.5% chance
      const static int FAILURE_THRESHOLD = (int)(((double)(RAND_MAX)) * FAILURE_RATE);

      if (checkpoint <= 1 && task1_seg1(FAILURE_THRESHOLD)) {
        return 1;
      }
      if (checkpoint <= 2 && task1_seg2(FAILURE_THRESHOLD)) {
        return 2;
      }
      if (checkpoint <= 3 && task1_seg3(FAILURE_THRESHOLD)) {
        return 3;
      }
      return 0;
    }
  =}

  reaction(start_seg) -> f_seg {=
    int result = total_task1(start_seg->value);
    lf_set(f_seg, result);
  =}
}

reactor Task1 extends TaskRetryTemplate {
  task1body = new Task1Body()

  trigger.start_seg -> task1body.start_seg
  trigger.start_seg -> advance.seg_start_num
  task1body.f_seg->advance.f_seg
  advance.failed_seg->failed_seg
}

// With no advancing logical time.
reactor Task2 extends TaskRetryNoAdvance{
  task2body = new Task1Body()
  trigger.start_seg -> task2body.start_seg
  task2body.f_seg->failed_seg
}

reactor Task3 extends TaskRetryWorstCaseTemplate {
  task1body = new Task1Body()

  trigger.start_seg -> task1body.start_seg
  trigger.start_seg -> advance.seg_start_num
  task1body.f_seg->advance.f_seg
  advance.failed_seg->failed_seg
}
