/**
 * This program models a redundant fault tolerant system where a primary node, if and when it fails,
 * is replaced by a backup node. The protocol is described in this paper:
 *
 * Bjarne Johansson; Mats RÃ¥gberger; Alessandro V. Papadopoulos; Thomas Nolte, "Consistency Before
 * Availability: Network Reference Point based Failure Detection for Controller Redundancy," Emerging
 * Technologies and Factory Automation (ETFA), 12-15 September 2023, DOI: 10.1109/ETFA54631.2023.10275664
 *
 * The key idea in this protocol is that when a backup fails to detect the heartbeats of a primary
 * node, it becomes primary only if it has access to Network Reference Point (NRP), which is a point
 * in the network. This way, if the network becomes partitioned, only a backup that is on the side
 * of the partition that still has access to the NRP can become a primary. If a primary loses access
 * to the NRP, then it relinquishes its primary role because it is now on the wrong side of a
 * network partition. A backup on the right side of the partition will take over.
 * 
 * This implementation omits some details in the paper.  See NOTEs in the comments.
 *
 * @author Edward A. Lee
 * @author Marjan Sirjani
 */
target C {
  tracing: true,
  timeout: 20 s
}

preamble {=
  #ifndef NRF_FD
  #define NRF_FD
  #include "platform.h" // Defines PRINTF_TIME
  
  // Paper calls for manual intervention to set initial primary ID and NRP network.
  // Here, we just hardwire this choice using #define.
  #define INITIAL_PRIMARY_ID 1
  #define INITIAL_NRP_NETWORK 0
  
  enum message_type {
    heartbeat,
    ping_NRP,
    ping_NRP_response,
    request_new_NRP,
    new_NRP
  };
  typedef struct message_t {
    enum message_type type;
    int source;
    int destination;
    int payload;
  } message_t;
  #endif // NRF_FD
=}

reactor Node(
    id: int = 0,
    heartbeat_period: time = 1 s,
    max_missed_heartbeats: int = 2,
    fails_at_time: time = 0,      // For testing. 0 for no failure.
    ping_timeout: time = 500 ms,  // Time until ping is deemed to have failed.
    // Time until new NRP request is deemed to have failed.
    nrp_timeout: time = 500 ms) {
  // There are two network interfaces:
  @side("east")
  input[2] in: message_t
  output[2] out: message_t

  timer node_fails(fails_at_time)

  state heartbeats_missed: int[2] = {0}
  state primary: int = 0  // The known primary node.
  state ping_pending: bool = false
  state ping_timeout_pending: bool = false
  state become_primary_on_ping_response: bool = false
  state NRP_network: int = {= INITIAL_NRP_NETWORK =}
  state NRP_switch_id: int = 0   // 0 means not known.
  
  logical action ping_timed_out(ping_timeout)
  logical action new_NRP_request_timed_out(nrp_timeout)

  initial mode Waiting {
    reaction(startup) -> out {=
      // If I am the initial primary, broadcast a ping on network 1.
      // The first switch to get this will respond.
      if (self->id == INITIAL_PRIMARY_ID) {
        message_t ping_message = {ping_NRP, self->id, 0, 0};
        lf_set(out[INITIAL_NRP_NETWORK], ping_message);
        // Instead of scheduling ping_timed_out, we just continue waiting until a ping response arrives. 
      }
    =}

    reaction(in) -> out, reset(Backup), reset(Primary) {=
      // Iterate over input channels.
      for (int c = 0; c < in_width; c++) {
        if (in[c]->is_present) {
          // In this mode, primary is waiting for a ping response and backup for a new NRP.
          if (self->id == INITIAL_PRIMARY_ID && in[c]->value.type == ping_NRP_response) {
            // Become primary.
            self->primary = self->id;
            lf_set_mode(Primary);
          
            lf_print(PRINTF_TIME ": Primary node %d received ping response on network %d. "
                "Making switch %d the NRP.", lf_time_logical_elapsed(), self->id, c, in[c]->value.source
            );
            self->NRP_network = c;
            self->NRP_switch_id = in[c]->value.source;
            // Notify the backup of the NRP. Destination 0 here means broadcast.
            message_t message = {new_NRP, self->id, 0, in[c]->value.source};
            // Send new NRP message on all networks.
            for (int i = 0; i < out_width; i++) lf_set(out[i], message);
          } else if (in[c]->value.type == new_NRP) {
            // Become backup.  Source of the message is the primary.
            self->primary = in[c]->value.source;
            lf_set_mode(Backup);
          }
        }
      }
    =}
  }  // mode Waiting

  mode Primary {
    timer heartbeat(0, heartbeat_period)
    reaction(reset) {=
      lf_print(PRINTF_TIME ": ---- Node %d becomes primary.", lf_time_logical_elapsed(), self->id);
    =}

    reaction(node_fails) -> reset(Failed) {=
      if(lf_time_logical_elapsed() > 0LL) lf_set_mode(Failed);
    =}

    reaction(heartbeat) -> out, ping_timed_out {=
      lf_print(PRINTF_TIME ": Primary node %d sends heartbeat on both networks.",
          lf_time_logical_elapsed(), self->id
      );
      message_t message = {heartbeat, self->id, 0, 0};
      for (int i = 0; i < out_width; i++) lf_set(out[i], message);
      
      // Ping the NRP if there is one and there isn't a ping timeout pending.
      if (self->NRP_switch_id != 0 && !self->ping_timeout_pending) {
        message_t ping = {ping_NRP, self->id, self->NRP_switch_id, 0};
        lf_set(out[self->NRP_network], ping);
        self->ping_pending = true;
        self->ping_timeout_pending = true;
        lf_schedule(ping_timed_out, 0);
      }
    =}

    reaction(in) -> out, ping_timed_out {=
      // Iterate over input channels.
      for (int c = 0; c < in_width; c++) {
        if (in[c]->is_present) {
          if (in[c]->value.type == request_new_NRP) {
            // Backup is asking for a new NRP. Invalidate current NRP.
            self->NRP_switch_id = 0;

            // Switch networks.
            if (self->NRP_network == 0) self->NRP_network = 1;
            else self->NRP_network = 0;

            lf_print(PRINTF_TIME ": Primary node %d looking for new NRP on network %d.",
                lf_time_logical_elapsed(), self->id, self->NRP_network
            );
            message_t message = {ping_NRP, self->id, 0, 0};
            lf_set(out[self->NRP_network], message);
            self->ping_pending = true;
            self->ping_timeout_pending = true;
            lf_schedule(ping_timed_out, 0);
          } else if (in[c]->value.type == ping_NRP_response) {
            lf_print(PRINTF_TIME ": Primary node %d received ping response on network %d. NRP is %d.",
                lf_time_logical_elapsed(), self->id, c, in[c]->value.source
            );
            self->ping_pending = false;
            if (self->NRP_switch_id == 0) {
              // This is a new NRP.
              self->NRP_switch_id = in[c]->value.source;
              // Notify the backup of the NRP. Destination 0 here means broadcast.
              message_t message = {new_NRP, self->id, 0, in[c]->value.source};
              // Send new NRP message on all networks.
              for (int i = 0; i < out_width; i++) lf_set(out[i], message);
              lf_print(PRINTF_TIME ": Primary node %d notifies backup of new NRP %d.",
                  lf_time_logical_elapsed(), self->id, self->NRP_switch_id
              );
              // NOTE: Should the primary get some confirmation from the backup?
            }
          }
        }
      }
    =}
    
    reaction(ping_timed_out) -> out, ping_timed_out, Failed {=
      self->ping_timeout_pending = false;
      if (self->ping_pending) {
        // Ping timed out.
        self->ping_pending = false;
        lf_print(PRINTF_TIME ": Primary node %d gets no response from ping.",
            lf_time_logical_elapsed(), self->id
        );
        if (self->NRP_switch_id == 0) {
          // Failed to get a new NRP. Declare failure.
          lf_set_mode(Failed);
        } else {
          // Invalidate current NRP.
          self->NRP_switch_id = 0;

          // Switch networks.
          if (self->NRP_network == 0) self->NRP_network = 1;
          else self->NRP_network = 0;

          lf_print(PRINTF_TIME ": Primary node %d looking for new NRP on network %d.",
              lf_time_logical_elapsed(), self->id, self->NRP_network
          );
          message_t message = {ping_NRP, self->id, 0, 0};
          lf_set(out[self->NRP_network], message);
          self->ping_pending = true;
          lf_schedule(ping_timed_out, 0);
        }
      }
    =}    
  } // mode Primary

  mode Backup {
    timer t(heartbeat_period, heartbeat_period)
    // NOTE: Paper says to SENDIMHERETOPRIMARY with "longer interval".
    // Is this really necessary?
    reaction(reset) {=
      lf_print(PRINTF_TIME ": ---- Node %d becomes backup.", lf_time_logical_elapsed(), self->id);
    =}

    reaction(node_fails) -> reset(Failed) {=
      if(lf_time_logical_elapsed() > 0LL) lf_set_mode(Failed);
    =}

    reaction(in) -> reset(Primary) {=
      // Iterate over input channels.
      for (int c = 0; c < in_width; c++) {
        if (in[c]->is_present) {
          if (in[c]->value.type == heartbeat) {
            lf_print(PRINTF_TIME ": Backup node %d received heartbeat from node %d on network %d.",
                lf_time_logical_elapsed(), self->id, in[c]->value.source, c
            );
            self->heartbeats_missed[c] = 0;
          } else if (in[c]->value.type == ping_NRP_response && in[c]->value.destination == self->id) {
            // Got a response from the NRP to a ping we sent.
            lf_print(PRINTF_TIME ": Backup node %d received ping response on network %d from NRP on switch %d.",
                lf_time_logical_elapsed(), self->id, c, in[c]->value.source
            );
            // If there was a timeout on both networks that was not simultaneous, then
            // we tried pinging the NRP before becoming primary.
            if (self->become_primary_on_ping_response) {
              lf_set_mode(Primary);
              self->become_primary_on_ping_response = false;
            }
            self->ping_pending = false;
          } else if (in[c]->value.type == new_NRP) {
            // NOTE: Should ping the new NRP and send confirmation back to primary.
            self->NRP_network = c;
            self->NRP_switch_id = in[c]->value.source;
          }
        }
      }
    =}

    reaction(t) -> reset(Primary), out, ping_timed_out {=
      if (self->heartbeats_missed[0] > self->max_missed_heartbeats
          && self->heartbeats_missed[1] > self->max_missed_heartbeats) {
        // Simultaneous heartbeat misses.
        // In the paper, this is tmoAllNotSimul.
        // For the tmoAllSimul optimization in the paper, we assume that if
        // self->heartbeats_missed[0] == self->heartbeats_missed[1], then most likely, it is
        // the primary that failed, and not the network, so can immediately become the primary.
        // Otherwise, it is possible that one network failed, and then the other failed, in which
        // case, we may have a partitioned network.
        lf_print(PRINTF_TIME ": **** Backup node %d detects missing heartbeats on both networks.",
            lf_time_logical_elapsed(), self->id
        );
        if (self->heartbeats_missed[0] == self->heartbeats_missed[1]) {
          lf_print(PRINTF_TIME ": **** Missing heartbeats on both networks were simultaneous. "
              "Assume the primary failed.",
              lf_time_logical_elapsed()
          );
          lf_set_mode(Primary);
        } else {
          // Ping the NRP because if we can't access it, we are on the wrong side of
          // a network partition and could end up with two primaries.
          message_t message = {ping_NRP, self->id, self->NRP_switch_id, 0};
          lf_set(out[self->NRP_network], message);
          // Wait for a response before becoming primary.
          self->become_primary_on_ping_response = true;
          lf_schedule(ping_timed_out, 0);
        }
        self->heartbeats_missed[0] = 0; // Prevent detecting again immediately.
        self->heartbeats_missed[1] = 0;
      } else if (self->heartbeats_missed[0] > self->max_missed_heartbeats
          || self->heartbeats_missed[1] > self->max_missed_heartbeats) {
        // Heartbeat missed on one network but not yet on the other.
        // Ping the NRP to make sure we retain access to it so that we can be an effective backup.
        // This corresponds to tmoSomeNotAll in the paper.
        lf_print(PRINTF_TIME ": **** Backup node %d detects missing heartbeats on one network.",
            lf_time_logical_elapsed(), self->id
        );
        // Ping the NRP.
        message_t message = {ping_NRP, self->id, self->NRP_switch_id, 0};
        if (!self->ping_pending && self->NRP_switch_id != 0) {
          lf_set(out[self->NRP_network], message);
          lf_print(PRINTF_TIME ": Backup node %d pings NRP on network %d, switch %d",
              lf_time_logical_elapsed(), self->id, self->NRP_network, self->NRP_switch_id
          );
          self->ping_pending = true;
          lf_schedule(ping_timed_out, 0);
        }
      }
      // Increment the counters so if they are not reset to 0 by the next time,
      // we detect the missed heartbeat.
      self->heartbeats_missed[0]++;
      self->heartbeats_missed[1]++;
    =}

    reaction(ping_timed_out) -> out, new_NRP_request_timed_out, Failed {=
      self->ping_timeout_pending = false;
      if (self->ping_pending) {
        // Ping timed out.
        lf_print(PRINTF_TIME ": Backup node %d gets no response from ping.", lf_time_logical_elapsed(), self->id);
        if (self->NRP_switch_id != 0) {
          // Send request for new NRP on the other network.
          lf_print(PRINTF_TIME ": Backup node %d requests new NRP.", lf_time_logical_elapsed(), self->id);

          // Invalidate current NRP.
          self->NRP_switch_id = 0;

          // Switch networks.
          if (self->NRP_network == 0) self->NRP_network = 1;
          else self->NRP_network = 0;

          message_t message = {request_new_NRP, self->id, self->primary, 0};
          lf_set(out[self->NRP_network], message);

          lf_schedule(new_NRP_request_timed_out, 0);
        } else {
          // Failed to connect to new NRP.
          lf_set_mode(Failed);
        }
        self->ping_pending = false;
      }
    =}

    reaction(new_NRP_request_timed_out) {=
      if (self->NRP_switch_id == 0) {
        lf_print(PRINTF_TIME ": Backup node %d new NRP request timed out. Will not function as backup.",
            lf_time_logical_elapsed(), self->id
        );
        if (self->become_primary_on_ping_response) {
          lf_print(PRINTF_TIME ": Network is likely partitioned. Remaining as (non-functional) backup.",
              lf_time_logical_elapsed()
          );
          self->become_primary_on_ping_response = false;
        }
      }
    =}
  }

  mode Failed {
    reaction(reset) {=
      lf_print(PRINTF_TIME ": #### Node %d fails.", lf_time_logical_elapsed(), self->id);
    =}
  }
}

/**
 * Switch with two interfaces. When a ping_NRP message arrives on either interface, if the
 * destination matches the ID of this switch or the destination is 0, then the switch responds on
 * the same interface with a ping_NRP_response message. When any other message arrives on either
 * interface, the switch forwards a copy of the message to the other interface. If any two messages
 * would be simultaneous on an output, one will be sent one microstep later.
 */
reactor Switch(
    id: int = 0,
    // For testing. 0 for no failure.
    fails_at_time: time = 0) {
  input in1: message_t
  @side("east")
  input in2: message_t
  @side("west")
  output out1: message_t
  output out2: message_t

  logical action pending_out1: message_t
  logical action pending_out2: message_t

  timer switch_fails(fails_at_time)

  initial mode Working {
    reaction(switch_fails) -> reset(Failed) {=
      if(lf_time_logical_elapsed() > 0LL) lf_set_mode(Failed);
    =}

    reaction(pending_out1) -> out1 {=
      lf_set(out1, pending_out1->value);
    =}

    reaction(pending_out2) -> out2 {=
      lf_set(out2, pending_out2->value);
    =}

    reaction(in1, in2) -> out1, out2, pending_out1, pending_out2 {=
      if (in1->is_present) {
        if (in1->value.type == ping_NRP) {
          if (in1->value.destination == self->id || in1->value.destination == 0) {
            lf_print(PRINTF_TIME ": ==== Switch %d pinged by node %d. Responding.", lf_time_logical_elapsed(), self->id, in1->value.source);
            // Respond to the ping.
            message_t message = {ping_NRP_response, self->id, in1->value.source};
            if (!out1->is_present) {
              lf_set(out1, message);
            } else {
              lf_schedule_copy(pending_out1, 0, &message, 1);
            }
          } else {
            // Forward the ping.
            if (!out2->is_present) {
              lf_set(out2, in1->value);
            } else {
              lf_schedule_copy(pending_out2, 0, &in1->value, 1);
            }
          }
        } else {
          // Forward the message.
          if (!out2->is_present) {
            lf_set(out2, in1->value);
          } else {
            lf_schedule_copy(pending_out2, 0, &in1->value, 1);
          }
        }
      }
      if (in2->is_present) {
        if (in2->value.type == ping_NRP) {
          if (in2->value.destination == self->id) {
            lf_print(PRINTF_TIME ": ==== Switch %d pinged by node %d. Responding.", lf_time_logical_elapsed(), self->id, in2->value.source);
            // Construct a response to the ping.
            message_t message = {ping_NRP_response, self->id, in2->value.source};
            // Respond to the ping if out2 is available.
            if (!out2->is_present) {
              lf_set(out2, message);
            } else {
              lf_schedule_copy(pending_out2, 0, &message, 1);
            }
          } else {
            // Forward the ping to out1 if out1 is available.
            if (!out1->is_present) {
              lf_set(out1, in2->value);
            } else {
              lf_schedule_copy(pending_out1, 0, &in2->value, 1);
            }
          }
        } else {
          // Forward the message if out1 is available.
          if (!out1->is_present) {
            lf_set(out1, in2->value);
          } else {
            lf_schedule_copy(pending_out1, 0, &in2->value, 1);
          }
        }
      }
    =}
  }

  mode Failed {
    reaction(reset) {=
      lf_print(PRINTF_TIME ": ==== Switch %d fails.", lf_time_logical_elapsed(), self->id);
    =}
  }
}
// FIXME: This should be federated, but bugs in federated execution make it fail.
main reactor(heartbeat_period: time = 1 s, delay: time = 1 ms) {
  node1 = new Node(heartbeat_period=heartbeat_period, id=1, fails_at_time = 10 s)
  switch1 = new Switch(id=1, fails_at_time = 3 s)
  switch3 = new Switch(id=3)

  node2 = new Node(heartbeat_period=heartbeat_period, id=2, fails_at_time = 15 s)
  switch2 = new Switch(id=2)
  switch4 = new Switch(id=4)

  node1.out -> switch1.in1, switch3.in1 after delay
  switch1.out1, switch3.out1 -> node1.in after delay

  switch1.out2 -> switch2.in2 after delay
  switch2.out2 -> switch1.in2 after delay

  switch2.out1, switch4.out1 -> node2.in after delay
  node2.out -> switch2.in1, switch4.in1 after delay

  switch3.out2 -> switch4.in2 after delay
  switch4.out2 -> switch3.in2 after delay
}
