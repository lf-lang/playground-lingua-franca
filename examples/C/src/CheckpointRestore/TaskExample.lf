target C

import TaskRetryTemplate from "lib/TaskRetryTemplate.lf"

reactor Task1<IN_T, OUT_T, CHECK_T> extends TaskRetryTemplate {
  preamble {=
    #define TASK1_SEG1_SLEEP_MSEC  200
    #define TASK1_SEG2_SLEEP_MSEC  200
    #define TASK1_SEG3_SLEEP_MSEC  200
    #define FAILURE_RATE 20 // % chance

    int task1_seg1(int in, int* out) {
      lf_sleep(MSEC(TASK1_SEG1_SLEEP_MSEC));
      if (rand() % 100 < FAILURE_RATE) {
        return 1;
      } else {
        *out = in + 1;
        return 0;
      }
    }

    int task1_seg2(int in, int* out) {
      lf_sleep(MSEC(TASK1_SEG2_SLEEP_MSEC));
      if (rand() % 100 < FAILURE_RATE) {
        return 2;
      } else {
        *out = in + 2;
        return 0;
      }
    }

    int task1_seg3(int in, int* out) {
      lf_sleep(MSEC(TASK1_SEG3_SLEEP_MSEC));
      if (rand() % 100 < FAILURE_RATE) {
        return 3;
      } else {
        *out = in + 3;
        return 0;
      }
    }

    int total_task1(int in, int* out, int* saved_value, int checkpoint) {
      if (checkpoint <= 1 && task1_seg1(in, saved_value)) return 1;
      if (checkpoint <= 2 && task1_seg2(*saved_value, saved_value)) return 2;
      if (checkpoint <= 3 && task1_seg3(*saved_value, saved_value)) return 3;
      *out = *saved_value;
      return 0;
    }
  =}
  input task_input: IN_T
  output task_output: OUT_T
  state task_input: IN_T
  state task_output: OUT_T

  state saved_value: CHECK_T

  reaction(new_instance, task_input) {=
    self->saved_value = 0;
    self->task_input = task_input->value;
  =}

  reaction(advance_lt) -> task_output {=
    // If the failed_seg signal is 0, the Task was finished. Trigger the output value.
    if (advance_lt->value == 0) {
      lf_set(task_output, self->task_output);
    }
  =}

  reaction(trigger_task) -> calculate_lt {=
    lf_schedule_int(calculate_lt, 0, total_task1(self->task_input, &self->task_output, &self->saved_value, self->seg_start_num));
    lf_print("Saved_value: %d", self->saved_value);
  =}
}

reactor Task2<IN_T, OUT_T, CHECK_T> extends TaskRetryTemplate {
  preamble {=
    #define TASK2_SEG1_SLEEP_MSEC  200
    #define TASK2_SEG2_SLEEP_MSEC  200
    #define TASK2_SEG3_SLEEP_MSEC  200
    #define FAILURE_RATE 50 // % chance

    int task2_seg1(int in, int* out) {
      lf_sleep(MSEC(TASK2_SEG1_SLEEP_MSEC));
      if (rand() % 100 < FAILURE_RATE) {
        return 1;
      } else {
        *out = in + 1;
        return 0;
      }
    }

    int task2_seg2(int in, int* out) {
      lf_sleep(MSEC(TASK2_SEG2_SLEEP_MSEC));
      if (rand() % 100 < FAILURE_RATE) {
        return 2;
      } else {
        *out = in + 2;
        return 0;
      }
    }

    int task2_seg3(int in, int* out) {
      lf_sleep(MSEC(TASK2_SEG3_SLEEP_MSEC));
      if (rand() % 100 < FAILURE_RATE) {
        return 3;
      } else {
        *out = in + 3;
        return 0;
      }
    }

    int task2_seg4(int in, int* out) {
      lf_sleep(MSEC(TASK2_SEG3_SLEEP_MSEC));
      if (rand() % 100 < FAILURE_RATE) {
        return 4;
      } else {
        *out = in + 4;
        return 0;
      }
    }

    int total_task2(int in, int* out, int* saved_value, int checkpoint) {
      if (checkpoint <= 1 && task2_seg1(in, saved_value)) return 1;
      if (checkpoint <= 2 && task2_seg2(*saved_value, saved_value)) return 2;
      if (checkpoint <= 3 && task2_seg3(*saved_value, saved_value)) return 3;
      if (checkpoint <= 4 && task2_seg4(*saved_value, saved_value)) return 4;
      *out = *saved_value;
      return 0;
    }
  =}
  input task_input: IN_T
  output task_output: OUT_T
  state task_input: IN_T
  state task_output: OUT_T

  state saved_value: CHECK_T

  reaction(new_instance, task_input) {=
    self->saved_value = 0;
    self->task_input = task_input->value;
  =}

  reaction(advance_lt) -> task_output {=
    // If the failed_seg signal is 0, the Task was finished. Trigger the output value.
    if (advance_lt->value == 0) {
      lf_set(task_output, self->task_output);
    }
  =}
  reaction(trigger_task) -> calculate_lt {=
    lf_schedule_int(calculate_lt, 0, total_task2(self->task_input, &self->task_output, &self->saved_value, self->seg_start_num));
    lf_print("Saved_value: %d", self->saved_value);
  =}
}
