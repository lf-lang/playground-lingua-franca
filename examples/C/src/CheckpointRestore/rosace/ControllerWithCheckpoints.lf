target C

import TaskRetryTemplate, TaskBody, CheckDeadlineAndRetry from "../lib/TaskRetryTemplate.lf"

preamble {=
  #define REAL_TYPE double

  #define delta_th_eq (1.5868660794926)
  #define delta_e_eq (0.012009615652468)

  #define FAILURE_RATE 30 // % chance

  #ifndef TASK_INFO_T_DEFINED
  #define TASK_INFO_T_DEFINED
  typedef struct task_info_t {
    uint16_t task_num;
    uint16_t dead_line;
    uint16_t num_of_segs;
    uint16_t* wcet;
    uint16_t* optwcet;
  } task_info_t;
  #endif
=}

reactor Filter(
    period: time = 10 ms,
    a: double[] = {0.0, 0.0},
    b: double[] = {0.0, 0.0},
    init_x1: double = 0.0,
    init_x2: double = 0.0) {
  input x: double
  output y: double

  state x1: double = 0.0
  state x2: double = 0.0

  timer t(0, period)

  reaction(startup) {=
    self->x1 = self->init_x1;
    self->x2 = self->init_x2;
  =}

  reaction(t) -> y {=
    lf_set(y, self->x2);
  =}

  reaction(t) x {=
    double x1_tmp = - self->a[0] * self->x2 + self->b[0] * x->value;
    double x2_tmp = self->x1 - self->a[1] * self->x2 + self->b[1] * x->value;
    // Update
    self->x1 = x1_tmp;
    self->x2 = x2_tmp;
  =}
}

reactor Hold(
    period: time = 20 ms,
    Kp_h: double = 0.1014048,
    Ki_h: double = 0.0048288,
    h_switch: double = 50.0,
    Vz_c: double = -2.5,
    Va_c: double = 0.0,
    h_c: double = 11000) {
  timer t(0, period)

  input s: double   // Set point
  input x: double   // Measurement

  output c: double  // Command

  state integrator: double = 532.2730285

  reaction(t) s, x -> c {=
    double y = 0.0;

    double Ts_h = ((double)self->period)/1e9; // Period in seconds. (1.0/50.0)

    if ((x->value - s->value) < -self->h_switch) {
      // Output
      y = self->Vz_c;
    } else if ((x->value - s->value) > self->h_switch) {
      // Output
      y = -self->Vz_c;
    } else {
      // Output
      y = self->Kp_h * (x->value - s->value) + self->Ki_h * self->integrator;
      // State
      self->integrator += Ts_h * (x->value - s->value);
    }

    lf_set(c, y);
  =}
}

reactor VaControl50Body extends TaskBody {
  preamble {=
    const REAL_TYPE K1_intVa =   0.049802610664357;
    const REAL_TYPE K1_Va     = -0.486813084356079;
    const REAL_TYPE K1_Vz     = -0.077603095495388;
    const REAL_TYPE K1_q      = 21.692383376322041;
    const REAL_TYPE Va_eq       = 230.0;

    int Va_control_50(REAL_TYPE Va_f, REAL_TYPE Vz_f, REAL_TYPE q_f, REAL_TYPE Va_c, REAL_TYPE* output, REAL_TYPE* saved_y, REAL_TYPE* saved_integrator,int seg_start_num){
    	static REAL_TYPE y = 0.0;
    	static REAL_TYPE Ts_K1 = 1.0/50.0;
    	static REAL_TYPE integrator = 0.0;

      // // Output
    	// y = K1_intVa * integrator + K1_Va * (Va_f - Va_eq) + K1_Vz * Vz_f + K1_q * q_f + delta_th_eq;
    	// // State
    	// integrator += Ts_K1 * (Va_c - Va_f + Va_eq);
      // *output = y;
      // return 0;

      // Output
      if (seg_start_num <= 1) {
        // Check if input is correct.
    	  y = K1_intVa * integrator + K1_Va * (Va_f - Va_eq) + K1_Vz * Vz_f + K1_q * q_f + delta_th_eq;
        if (rand() % 100 < FAILURE_RATE) {
          return 1;
        } else {
          *saved_y = y;
          *saved_integrator = integrator;
          // lf_print("Va:*saved_integrator = %f\n", *saved_integrator);
        }
      }
      if (seg_start_num <= 2) {
        // Load the saved value. However, inefficient when no failures between checkpoint 1 and 2.
        integrator = *saved_integrator;
        // lf_print("Va:Before: integrator: %f\n", integrator);
        // State
    	  integrator += Ts_K1 * (Va_c - Va_f + Va_eq);
        // lf_print("Va:After: integrator: %f\n", integrator);
        if (rand() % 100 < FAILURE_RATE) {
          return 2;
        } else {
        *output = *saved_y;
        // *output = y;
        }
        return 0;
      }
      return 0; // Just to avoid warnings.
    }
  =}
  input Va_f: double  // filtered true airspeed
  input Vz_f: double  // filtered vertical climb rate
  input q_f: double   // filtered pitch rate
  input Va_c: double  // Commanded true airspeed setpoint
  output delta_th_c: double

  state delta_th_c: double

  state saved_y: double
  state saved_integrator: double

reaction(trigger_task) Va_f, Vz_f, q_f, Va_c -> calculate_lt, delta_th_c {=
  // lf_print("VaControl: Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
  int result = Va_control_50(Va_f->value, Vz_f->value, q_f->value, Va_c->value, &self->delta_th_c, &self->saved_y, &self->saved_integrator, trigger_task->value);
  // lf_print("Va:delta_th_c: %f", self->delta_th_c);
  lf_set(calculate_lt, result);
  // If the failed_seg signal is 0, the Task was finished. Trigger the output value.
  if (result == 0) {
    lf_set(delta_th_c, self->delta_th_c);
  }
=}
}

reactor VaControl50Tail{
  input trigger_output: int
  input delta_th_c: double
  output delta_thc: double

  reaction(trigger_output) delta_th_c -> delta_thc {=
  // If the failed_seg signal is 0, the Task was finished. Trigger the output value.
  // Already checked when sent from TaskBody, but check again to not trigger uninitialized values.
    if (trigger_output->value == 0) {
      lf_set(delta_thc, delta_th_c->value);
      // lf_print("VaControlTail: Current Logical time: %lld msecs, microstep: %d", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep);
      // lf_print("Sending delta_thc: %f", delta_thc->value);
    }  
  =}
}

reactor VaControl50 extends TaskRetryTemplate {

  input Va_f: double  // filtered true airspeed
  input Vz_f: double  // filtered vertical climb rate
  input q_f: double   // filtered pitch rate
  input Va_c: double  // Commanded true airspeed setpoint
  output delta_thc: double

  va_body = new VaControl50Body()
  va_tail = new VaControl50Tail()

  Va_f, Vz_f, q_f, Va_c -> va_body.Va_f, va_body.Vz_f, va_body.q_f, va_body.Va_c

  trigger.trigger_task -> va_body.trigger_task
  va_body.calculate_lt->advance.calculate_lt
  advance.failed_seg->failed_seg
  advance.failed_seg->va_tail.trigger_output
  va_body.delta_th_c->va_tail.delta_th_c
  va_tail.delta_thc->delta_thc
}

reactor VzControl50Body extends TaskBody {
  preamble {=
      const REAL_TYPE K2_intVz   = 0.000627342822264;
      const REAL_TYPE K2_Vz     = -0.003252836726554;
      const REAL_TYPE K2_q       = 0.376071446897134;
      const REAL_TYPE K2_az     = -0.001566907423747;

      int Vz_control_50(REAL_TYPE Vz_f, REAL_TYPE Vz_c, REAL_TYPE q_f, REAL_TYPE az_f, REAL_TYPE* output, REAL_TYPE* saved_y, REAL_TYPE* saved_integrator, int seg_start_num){
        static REAL_TYPE y = 0.0;
        static REAL_TYPE Ts_K2 = 1.0/50.0;
        static REAL_TYPE integrator = 0.0;

        // Output
        if (seg_start_num <= 1) {
          // Check if input is correct.
          y = K2_intVz * integrator + K2_Vz * Vz_f + K2_q * q_f + K2_az * az_f + delta_e_eq;
          if (rand() % 100 < FAILURE_RATE) {
            return 1;
          } else {
            *saved_y = y;
            *saved_integrator = integrator;
            // lf_print("Vz:*saved_integrator = %f\n", *saved_integrator);
          }
        }
        if (seg_start_num <= 2) {
          // Load the saved value. However, inefficient when no failures between checkpoint 1 and 2.
          integrator = *saved_integrator;
          // lf_print("Vz:Before: integrator: %f\n", integrator);
          // State
          integrator += Ts_K2 * (Vz_c - Vz_f);
          // lf_print("Vz:After: integrator: %f\n", integrator);
          if (rand() % 100 < FAILURE_RATE) {
            return 2;
          } else {
          *output = *saved_y;
          // *output = y;
          }
        return 0;
      }
    }
  =}
  input Vz_f: double
  input Vz_c: double
  input q_f: double
  input az_f: double
  output delta_e_c: double

  state delta_e_c: double

  state saved_y: double
  state saved_integrator: double

  reaction(trigger_task) Vz_f, Vz_c, q_f, az_f -> calculate_lt, delta_e_c {=
    // lf_print("VzControl: Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
    int result = Vz_control_50(Vz_f->value, Vz_c->value, q_f->value, az_f->value, &self->delta_e_c, &self->saved_y, &self->saved_integrator, trigger_task->value);
    // lf_print("Vz:delta_e_c: %f", self->delta_e_c);
    lf_set(calculate_lt, result);
    // If the failed_seg signal is 0, the Task was finished. Trigger the output value.
    if (result == 0) {
      lf_set(delta_e_c, self->delta_e_c);
    }
  =}
}

reactor VzControl50Tail{
  input trigger_output: int
  input delta_e_c: double
  output delta_ec: double

  reaction(trigger_output) delta_e_c -> delta_ec {=
  // If the failed_seg signal is 0, the Task was finished. Trigger the output value.
  // Already checked when sent from TaskBody, but check again to not trigger uninitialized values.
    if (trigger_output->value == 0) {
      lf_set(delta_ec, delta_e_c->value);
      // lf_print("VzControlTail: Current Logical time: %lld msecs, microstep: %d", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep);
      // lf_print("Sending delta_ec: %f", delta_e_c->value);
    }  
  =}
}

reactor VzControl50 extends TaskRetryTemplate {

  input Vz_f: double
  input Vz_c: double
  input q_f: double 
  input az_f: double 
  output delta_ec: double

  vz_body = new VzControl50Body()
  vz_tail = new VzControl50Tail()

  Vz_f, Vz_c, q_f,  az_f -> vz_body.Vz_f, vz_body.Vz_c, vz_body.q_f, vz_body.az_f
  trigger.trigger_task -> vz_body.trigger_task
  vz_body.calculate_lt->advance.calculate_lt
  advance.failed_seg->failed_seg
  advance.failed_seg->vz_tail.trigger_output
  vz_body.delta_e_c->vz_tail.delta_e_c
  vz_tail.delta_ec->delta_ec
}


reactor VaControl50Retry {
  input Va_f: double
  input Vz_f: double
  input q_f: double
  input Va_c: double
  output delta_thc: double
  timer t(0, 20 msec)

  Va_ct_Retry = new VaControl50(
      task_num=2,
      dead_line=20,
      num_of_segs=2,
      wcet = {2, 2},
      optwcet = {1, 1})
  retry = new CheckDeadlineAndRetry()

  Va_ct_Retry.task_info_update -> retry.task_info_update
  Va_ct_Retry.instance_start_time -> retry.instance_start_time_update
  Va_ct_Retry.failed_seg -> retry.failed_seg
  retry.out -> Va_ct_Retry.retry after 0
  Va_f -> Va_ct_Retry.Va_f
  Vz_f -> Va_ct_Retry.Vz_f
  q_f -> Va_ct_Retry.q_f
  Va_c -> Va_ct_Retry.Va_c
  Va_ct_Retry.delta_thc -> delta_thc

  reaction(t) -> Va_ct_Retry.new_instance {=
    lf_set(Va_ct_Retry.new_instance, 0);
  =}
}

reactor VzControl50Retry {
  input Vz_f: double
  input Vz_c: double
  input q_f: double
  input az_f: double
  output delta_ec: double
  timer t(0, 20 msec)

  Vz_ct_Retry = new VzControl50(
      task_num=1,
      dead_line=20,
      num_of_segs=2,
      wcet = {2, 2},
      optwcet = {1, 1})
  retry = new CheckDeadlineAndRetry()

  Vz_ct_Retry.task_info_update -> retry.task_info_update
  Vz_ct_Retry.instance_start_time -> retry.instance_start_time_update
  Vz_ct_Retry.failed_seg -> retry.failed_seg
  retry.out -> Vz_ct_Retry.retry after 0
  Vz_f -> Vz_ct_Retry.Vz_f
  Vz_c -> Vz_ct_Retry.Vz_c
  q_f -> Vz_ct_Retry.q_f
  az_f -> Vz_ct_Retry.az_f
  Vz_ct_Retry.delta_ec -> delta_ec

  reaction(t) -> Vz_ct_Retry.new_instance {=
    lf_set(Vz_ct_Retry.new_instance, 0);
  =}
}

reactor NewController(filter_period: time = 10 ms) {
  // Sensor inputs from aircraft
  // Vertical speed
  input Vz: double
  input Va: double          // True airspeed
  input h: double           // Altitude measurement
  input az: double          // Vertical acceleration
  input q: double           // Pitch rate

  // Command inputs
  // Altitude command
  input c: double
  input s: double           // Speed command

  output delta_thc: double  // Engine control
  output delta_ec: double   // Elevator control

  h_c = new Hold()

  h_f = new Filter(
      period = 100 ms,
      init_x1 = {= h_eq * (1.0 - 1.477888930110354 /*a[1]*/ - 0.049596808318647 /*b1*/) =},
      init_x2 = {= h_eq =},
      a = {0.586756156020839, -1.477888930110354},
      b = {0.049596808318647, 0.059270417591839})
  az_f = new Filter(
      period=filter_period,
      init_x1=0.0,
      init_x2=0.0,
      a = {0.169118914523145, -0.518588903229759},
      b = {0.229019233988375, 0.421510777305010})
  Vz_f = new Filter(
      period=filter_period,
      init_x1=0.0,
      init_x2=0.0,
      a = {0.914975803093201, -1.911199519984605},
      b = {0.001860178914816, 0.001916104193780})
  q_f = new Filter(
      period=filter_period,
      init_x1=0.0,
      init_x2=0.0,
      a = {0.586756156020839, -1.477888930110354},
      b = {0.049596808318647, 0.059270417591839})
  Va_f = new Filter(
      period=filter_period,
      init_x1 = {= Va_eq * (1.0 - 1.911199519984605 /*a[1]*/ - 0.001916104193780 /*b[1]*/) =},
      init_x2 = {= Va_eq =},
      a = {0.914975803093201, -1.911199519984605},
      b = {0.001860178914816, 0.001916104193780})

  Va_ct = new VaControl50Retry()
  Vz_ct = new VzControl50Retry()

  h, az, Vz, q, Va -> h_f.x, az_f.x, Vz_f.x, q_f.x, Va_f.x
  c -> h_c.s
  h_f.y -> h_c.x

  Va_f.y, Vz_f.y, s, q_f.y -> Va_ct.Va_f, Va_ct.Vz_f, Va_ct.Va_c, Va_ct.q_f
  Vz_f.y, az_f.y, h_c.c, q_f.y -> Vz_ct.Vz_f, Vz_ct.az_f, Vz_ct.Vz_c, Vz_ct.q_f

  // Without Stabilizer  
  Va_ct.delta_thc -> delta_thc
  Vz_ct.delta_ec -> delta_ec
}
