/** @author Dongha Kim */
target C

preamble {=
  #include <stdlib.h> // rand()
  #include "platform.h" // lf_sleep()
  #ifndef TASK_INFO_T_DEFINED
  #define TASK_INFO_T_DEFINED
  typedef struct task_info_t {
    uint16_t task_num;
    uint16_t dead_line;
    uint16_t num_of_segs;
    uint16_t* wcet;
    uint16_t* optwcet;
  } task_info_t;
  #endif
=}

reactor TriggerTask (task_num: uint16_t = 0) {
  input new_instance: int
  input retry: int
  output trigger_task: int
  output instance_start_time: time

  reaction(new_instance, retry) -> trigger_task, instance_start_time {=
    int segment_start_num;
    if(retry->is_present) {
      // When Retry was triggered. retry->value should not be 0.
      if (retry->value != 0) {
        segment_start_num = retry->value;
      } else {
        // Don't trigger retry. 0 means the segment was completed.
        return;
      }
    } else { // When new_instance is triggered.
      // Can be triggered by the timer or anything. However, only start when the value is 0.
      if(new_instance->value == 0){
        segment_start_num = 1; // Start from segment 1.
        lf_set(instance_start_time, lf_time_logical_elapsed());
        // When timer triggers.
        lf_print("**** New instance of task %d starting. Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.\n", self->task_num, lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
      } else {
        // New instance should only be triggered when value is 0. Don't schedule to trigger task.
        return;
      }
    }
    lf_set(trigger_task, segment_start_num);
  =}
}

reactor AdvanceTime (
  task_num: uint16_t = 0,
  dead_line: uint16_t = 0,
  num_of_segs: uint16_t = 0,
  wcet: uint16_t[] = {},
  optwcet: uint16_t[] = {}) {
  input calculate_lt: int
  input seg_start_num: int

  logical action advance_lt: int
  output failed_seg: int

  reaction(calculate_lt) seg_start_num -> advance_lt {=
    // Calculate the number of successed segments. If failed_seg_num=3 and in seg_start_num=1, 2 segments success.
    int failed_seg_num = calculate_lt->value;
    int num_of_success = failed_seg_num - seg_start_num->value;
    if (num_of_success < 0) {
      // This means failed_seg_num was 0 and successed to end of task. Recalculate the number of successed segments.
      num_of_success +=  self->num_of_segs + 1;
    }

    // Schedule logical action to advance time.
    lf_print("TASK%d: Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.", self->task_num, lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));

    // Caluculate the time of the total successed segments.
    int total_success_time = 0; // msecs
    for (int i=0; i < num_of_success; i++){
      total_success_time += self->optwcet[seg_start_num->value + i -1];
    }

    if(failed_seg_num == 0) {
      // Task is finished. Advance as much as the sucessed segments.
      lf_schedule_int(advance_lt, total_success_time * MSEC(1), 0);
      lf_print("TASK%d: All segments finished. %d task(s) success. Advancing logical time by %d msecs. \n", self->task_num, num_of_success, total_success_time);
    } else {
      // Segment failed. Advance as much as successed segments + 1 failed segment.
      lf_schedule_int(advance_lt, total_success_time * MSEC(1) + self->wcet[failed_seg_num - 1] * MSEC(1), failed_seg_num);
      lf_print("TASK%d: Segment %d failed. %d task(s) success. Advancing logical time by %d msecs. \n", self->task_num, failed_seg_num, num_of_success, total_success_time + self->wcet[failed_seg_num - 1]);
    }
  =}

  reaction(advance_lt) -> failed_seg {=
    lf_set(failed_seg, advance_lt->value);
  =}
}

reactor AdvanceTimeWorstCase (
  task_num: uint16_t = 0,
  dead_line: uint16_t = 0,
  num_of_segs: uint16_t = 0,
  wcet: uint16_t[] = {},
  optwcet: uint16_t[] = {}) {
  input calculate_lt: int
  input seg_start_num: int

  logical action advance_lt: int
  output failed_seg: int

  reaction(calculate_lt) seg_start_num -> advance_lt {=
    // Calculate the number of successed segments. If failed_seg_num=3 and in seg_start_num=1, 2 segments success.
    int failed_seg_num = calculate_lt->value;
    int num_of_success = failed_seg_num - seg_start_num->value;
    if (num_of_success < 0) {
      // This means failed_seg_num was 0 and successed to end of task. Recalculate the number of successed segments.
      num_of_success +=  self->num_of_segs + 1;
    }

    // Schedule logical action to advance time.
    lf_print("TASK%d: Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.", self->task_num, lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));

    // Caluculate the time of the total successed segments.
    int total_success_time = 0; // msecs
    for (int i=0; i < num_of_success; i++){
      total_success_time += self->wcet[seg_start_num->value + i -1];
    }

    if(failed_seg_num == 0) {
      // Task is finished. Advance as much as the sucessed segments.
      lf_schedule_int(advance_lt, total_success_time * MSEC(1), 0);
      lf_print("TASK%d: All segments finished. %d task(s) success. Advancing logical time by %d msecs. \n", self->task_num, num_of_success, total_success_time);
    } else {
      // Segment failed. Advance as much as successed segments + 1 failed segment.
      lf_schedule_int(advance_lt, total_success_time * MSEC(1) + self->wcet[failed_seg_num - 1] * MSEC(1), failed_seg_num);
      lf_print("TASK%d: Segment %d failed. %d task(s) success. Advancing logical time by %d msecs. \n", self->task_num, failed_seg_num, num_of_success, total_success_time + self->wcet[failed_seg_num - 1]);
    }
  =}

  reaction(advance_lt) -> failed_seg {=
    lf_set(failed_seg, advance_lt->value);
  =}
}

reactor TaskRetryTemplate(
    task_num: uint16_t = 0,
    dead_line: uint16_t = 0,
    num_of_segs: uint16_t = 0,
    wcet: uint16_t[] = {},
    optwcet: uint16_t[] = {}) {
  input new_instance: int
  input retry: int

  output failed_seg: int
  output instance_start_time: time
  output task_info_update: task_info_t
  state task_info: task_info_t

  trigger = new TriggerTask(task_num = task_num)
  advance = new AdvanceTime(task_num = task_num, dead_line = dead_line, num_of_segs = num_of_segs, wcet = wcet, optwcet = optwcet)
  new_instance -> trigger.new_instance
  retry -> trigger.retry
  trigger.instance_start_time -> instance_start_time
  trigger.trigger_task -> advance.seg_start_num
  advance.failed_seg -> failed_seg

  reaction(startup) -> task_info_update {=
    self->task_info.task_num = self->task_num;
    self->task_info.num_of_segs = self->num_of_segs;
    self->task_info.wcet = self->wcet;
    self->task_info.optwcet = self->optwcet;
    self->task_info.dead_line = self->dead_line;
    lf_set(task_info_update, self->task_info);
  =}
}

reactor TaskRetryWorstCaseTemplate(
    task_num: uint16_t = 0,
    dead_line: uint16_t = 0,
    num_of_segs: uint16_t = 0,
    wcet: uint16_t[] = {},
    optwcet: uint16_t[] = {}) {
  input new_instance: int
  input retry: int

  output failed_seg: int
  output instance_start_time: time
  output task_info_update: task_info_t
  state task_info: task_info_t

  trigger = new TriggerTask(task_num = task_num)
  advance = new AdvanceTimeWorstCase(task_num = task_num, dead_line = dead_line, num_of_segs = num_of_segs, wcet = wcet, optwcet = optwcet)
  new_instance -> trigger.new_instance
  retry -> trigger.retry
  trigger.instance_start_time -> instance_start_time
  trigger.trigger_task -> advance.seg_start_num
  advance.failed_seg -> failed_seg

  reaction(startup) -> task_info_update {=
    self->task_info.task_num = self->task_num;
    self->task_info.num_of_segs = self->num_of_segs;
    self->task_info.wcet = self->wcet;
    self->task_info.optwcet = self->optwcet;
    self->task_info.dead_line = self->dead_line;
    lf_set(task_info_update, self->task_info);
  =}
}

reactor TaskBody{
  input trigger_task: int
  output calculate_lt: int
}

// Naming? Timely retry?
reactor CheckDeadlineAndRetry {
  input instance_start_time_update: time
  input failed_seg: int
  output out: int
  state instance_start_time: time
  state deadline_missed: int=0
  state task_dropped: int = 0
  input task_info_update: task_info_t
  state task_info: task_info_t

  reaction(task_info_update) {=
    self->task_info.task_num = task_info_update->value.task_num;
    self->task_info.num_of_segs = task_info_update->value.num_of_segs;
    self->task_info.wcet = task_info_update->value.wcet;
    self->task_info.optwcet = task_info_update->value.optwcet;
    self->task_info.dead_line = task_info_update->value.dead_line;
  =}

  reaction(instance_start_time_update) {=
    // Update the instance start time. This can also be implemented by a message by the Task reactor.
    self->instance_start_time = lf_time_logical_elapsed();
  =}

  reaction(failed_seg) -> out {=
    if(failed_seg->value == 0) {
      // 0 means, all segments are finished.
      // Still need to signal output with 0.
      // If the task's retry port gets 0, does nothing.
      // If the task's new_instance port gets 0, it starts a new instance.
      lf_set(out, 0);
    } else {
      // Check deadline in logical time. Does not schedule next retry, when deadline violation.

      // Caluculate the additional time required to finish task.
      int total_success_time = 0; // msecs
      for (int i=failed_seg->value; i <=  self->task_info.num_of_segs; i++){
        total_success_time += self->task_info.optwcet[i - 1];
      }

      instant_t min_instance_finish_time = lf_time_logical_elapsed() + total_success_time * MSEC(1);
      if(min_instance_finish_time > self->instance_start_time + (self->task_info.dead_line * MSEC(1))) {
        lf_print("TASK%d: Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.", self->task_info.task_num, lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
        lf_print("TASK%d: ****Logical time deadline violation predicted.\nDeadline is: %lld msecs, while minimum predicted instance finish time is %lld msecs.\nDropping left over tasks, and giving up instance.\n", self->task_info.task_num, (self->task_info.dead_line * MSEC(1) + self->instance_start_time)/ MSEC(1), min_instance_finish_time / MSEC(1));
        self->task_dropped++;

        // *****This else if tests when there is no deadline prediction!
        // Don't erase this part.
      } else if(self->task_info.dead_line * MSEC(1) < lf_time_logical_elapsed() - self->instance_start_time) {
        lf_print("\nLogical time deadline violation detected on Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.\nDeadline was: %lld msecs.\n", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1), (self->task_info.dead_line * MSEC(1) + self->instance_start_time)/ MSEC(1));
        self->deadline_missed++;
      } else {
        // Did not violate predicted deadline.
        lf_set(out, failed_seg->value);
      }
    }
  =}

  reaction(shutdown) {=
    lf_print("Deadline missed: %d", self->deadline_missed);
    lf_print("Task dropped: %d", self->task_dropped);
    lf_print("Execution failed: %d", self->task_dropped); // Always same with dropped.
  =}
}
