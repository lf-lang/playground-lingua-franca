target C {
  timeout: 10 sec
}

preamble {=
  #include <stdlib.h> // rand()
  #include "platform.h" // lf_sleep()
=}

reactor Task(period: time = 0 msec) {
  preamble {=
    #define TASK1_SLEEP_MSEC  200
    #define TASK2_SLEEP_MSEC  200
    #define TASK3_SLEEP_MSEC  200

    // // Temporary lookup table...
    // static const int TASK_SLEEP_TIMES[] = {
    //   0, // Index 0 is unused
    //   TASK1_SLEEP_MSEC + TASK2_SLEEP_MSEC + TASK3_SLEEP_MSEC, // For a->value == 1
    //   TASK2_SLEEP_MSEC + TASK3_SLEEP_MSEC, // For a->value == 2
    //   TASK3_SLEEP_MSEC // For a->value == 3
    // };

    int seg1() {
      lf_sleep(MSEC(TASK1_SLEEP_MSEC));
      if (rand() % 10 < 8) {  // 80% chance
        return 1;
      }
      return 0;
    }
    int seg2() {
      lf_sleep(MSEC(TASK2_SLEEP_MSEC));
      if (rand() % 10 < 8) {  // 80% chance
        return 2;
      }
      return 0;
    }
    int seg3() {
      lf_sleep(MSEC(TASK3_SLEEP_MSEC));
      if (rand() % 10 < 8) {  // 80% chance
        return 3;
      }
      return 0;
    }
    int total_task(int checkpoint) {
      int ret = -1;
      if (checkpoint <= 1) {  // Start from task1 if no checkpoint
        ret = seg1();
        if (ret != 0) {
          return ret; // Return failure checkpoint
        }
      }

      if (checkpoint <= 2) {  // Start from task2 if the previous step succeeded
        ret = seg2();
        if (ret != 0){
          return ret; // Return failure checkpoint
        }
      }
      if (checkpoint <= 3) {  // Start from task2 if the previous step succeeded
        ret = seg3();
        if (ret != 0){
          return ret; // Return failure checkpoint
        }
      }
      return 0;
    }
  =}
  timer t(0, period)
  input in: int
  output success: int
  output fail: int

  // reaction(t) ->in
  reaction(t) -> success, fail {=
    lf_print("New instance of task starting. Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
    int ret = total_task(1);
    lf_set(fail, ret);
    // Calculate the number of successed segments. If ret=3 and in in=1, 2 segments success. 
    int temp = ret - 1;
    if (temp >= 0) {
      lf_set(success, temp);
    } else if (temp < 0) {
      // This means ret was 0 and successed to end of task. Recalculate the number of successed segments.
      //TODO: 4 is hard coded. Chane it to total number of segments.
      lf_set(success, temp + 4);
    }
  =}

  reaction(in) -> success, fail {=
    int ret = total_task(in->value);
    lf_set(fail, ret);
    // Calculate the number of successed segments. If ret=3 and in in=1, 2 segments success. 
    int temp = ret - in->value;
    if (temp >= 0) {
      lf_set(success, temp);
    } else if (temp < 0) {
      // This means ret was 0 and successed to end of task. Recalculate the number of successed segments.
      //TODO: 4 is hard coded. Chane it to total number of segments.
      lf_set(success, temp + 4);
    }
  =}
}

reactor Retry(wcet: time = 20 msec, optwcet: time = 20 msec, period: time = 0 msec, dead_line: time = 0 msec) {

  timer t(0, period)

  input success: int
  input fail: int
  output out: int
  
  logical action check_deadline: int
  logical action trigger: int
  state instance_start_time: time
  // state instance_deadline: time


  reaction (t) {=
    // Update the instance start time. This can also be implemented by a message by the Task reactor.
    self->instance_start_time = lf_time_logical_elapsed();
    // self->instance_deadline = lf_time_logical_elapsed() + self->dead_line;
  =}

  reaction(success, fail)-> check_deadline {=
    lf_print("Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
    if (fail->value == 0) {
      // Task is finished. Advance as much as the sucessed segments.
      // TODO: What if different WCET per segment?
      lf_schedule_int(check_deadline, self->optwcet * success->value, 0);
      lf_print("All segments finished.");
      lf_print("%d tasks success. Advancing logical time by %lld. \n", success->value, self->optwcet * success->value / MSEC(1));
    } else {
      // Segment failed. Advance as much as successed segments + 1 failed segment.
      lf_schedule_int(check_deadline, self->optwcet * success->value + self->wcet, fail->value);
      lf_print("Segment %d failed. %d tasks success. Advancing logical time by %lld. \n", fail->value, success->value, (self->optwcet * success->value + self->wcet) / MSEC(1));
    }
  =}

  reaction(check_deadline) -> trigger {=
    // Check deadline in logical time. Does not schedule next retry, when deadline violation.
    //TODO: Now, check if it is schedulable, not doing everything.
    if(self->dead_line < lf_time_logical_elapsed() - self->instance_start_time) {
      lf_print("\nLogical time deadline violation detected on Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.\nDeadline was: %lld msecs.\n", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1), (self->dead_line + self->instance_start_time)/ MSEC(1));
    // } else if(self->dead_line < lf_time_logical_elapsed() - self->instance_start_time) {
    //   lf_print("\nLogical time deadline violation detected on Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.\nDeadline was: %lld msecs.\n", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1), (self->dead_line + self->instance_start_time)/ MSEC(1));
    } else {
      lf_schedule_int (trigger, 0, check_deadline->value);
    }
  =}
  reaction(trigger) -> out {=
    if(trigger->value == 0) {
      // 0 means, all segments are finished. Don't trigger the task again, so do nothing.
    } else {
      lf_set(out, trigger->value);
    }
  =}
  // reaction(success) -> a {=
  //   // First set that wcet of all tasks are same.
  //   // TODO: What if different WCET?
  //   // TODO: Success wcet, and failed wcet.
  //   lf_schedule(a, self->wcet * success->value);
  //   lf_print("Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
  //   lf_print("%d tasks success. Advancing logical time by %lld. \n", success->value, self->wcet * success->value / MSEC(1));
  // =}

  // reaction(fail) -> b {=
  //   // TODO: Different WCET?
  //   if (fail->value > 0) {
  //     lf_schedule_int(b, self->wcet, fail->value);
  //     lf_print("Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
  //     lf_print("Segment %d failed. Advancing logical time by %lld. \n", fail->value, self->wcet / MSEC(1));
  //   } else {
  //     lf_print("Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
  //     lf_print("All segments finished. \n");
  //   }
  // =}

  // reaction(a) {=
  //   // Do nothing.
  // =}

  // reaction(in) -> check_deadline {=
  // if(in->value == 0) {
  //     // Success.
  // lf_print("Task success. Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs\n", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
  //     // TODO: How much should I delay when success? Need to delay as much as LET.
  // lf_schedule_int (check_deadline, 0, in->value);
  //   } else {
  //     // Failed.
  //     // Need to retry with logical delay.
  //     // Need few inputs. 1. If failed or success. 2. How much logical time delay.
  // lf_print("Task Failed. Advancing logical time by %lld msecs. Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs\n", self->wcet / MSEC(1), lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
  // lf_schedule_int (check_deadline, self->wcet, in->value);
  //   }
  // =}
  // reaction(check_deadline) -> trigger {=
  //   // Check deadline in logical time. Does not schedule next retry, when deadline violation.
  //   //TODO: Now, check if it is schedulable, not doing everything.
  // if(self->dead_line < lf_time_logical_elapsed() - self->instance_start_time) {
  // lf_print("\nLogical time deadline violation detected on Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.\nDeadline was: %lld msecs.\n", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1), (self->dead_line + self->instance_start_time)/ MSEC(1));
  //   // } else if(self->dead_line < lf_time_logical_elapsed() - self->instance_start_time) {
  //   //   lf_print("\nLogical time deadline violation detected on Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.\nDeadline was: %lld msecs.\n", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1), (self->dead_line + self->instance_start_time)/ MSEC(1));
  //   } else {
  // lf_schedule_int (trigger, 0, check_deadline->value);
  //   }
  // =}
  // reaction(trigger) -> out {=
  // if(trigger->value == 0) {
  //     // Success
  // lf_set(out, self->seg_num + 1); // 0 means success, no need to retry.
  //   } else {
  //     // Failed.
  // lf_set(out, self->seg_num); // Failure. Should retry.
  //   }
  //   // out will be sent to both the current and next segment.
  //   // The current segment will retry looking the value 0,
  //   // The next segment will receive -1, does not try and do nothing.
  // =}
  // reaction(b) -> out {=
  //   lf_set(out, b->value);
  // =}
}

reactor Periodic(start_time: time = 0 msec, period: time = 0 msec) {
  timer t(start_time, period)
  output out: int

  // output instance_start_time: time
  // reaction(t) -> out, instance_start_time {=
  reaction(t) -> out {=
    lf_set(out, 1);
    // lf_set(instance_start_time, lf_time_logical_elapsed());
  =}
}

main reactor {
  task = new Task(period = 5000 msec)
  retry = new Retry(wcet = 300 msec, optwcet = 300 msec, period = 5000 msec, dead_line = 3000 msec)
  task.fail -> retry.fail
  task.success -> retry.success
  retry.out -> task.in after 0

  reaction(startup) {=
    srand(time(NULL));
  =}
}
