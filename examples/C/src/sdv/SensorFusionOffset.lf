/**
 * Sensor fusion mock up.
 * @author Ravi Akella
 * @author Marten Lohstroh
 */
target C {
  timeout: 10 sec,
  coordination: decentralized  // better performance than centralized
}

preamble {=
  #include "platform.h"
  #include <stdlib.h> // rand, srand
=}

@label("ASIL B")
reactor Sensor(period: time = 100 ms) {
  timer t(0, period)
  output y: int
  state count: int

  reaction(t) -> y {=
    lf_set(y, self->count);
    self->count++;
  =}
}

@label("ASIL D")
reactor Processor(processingDelay: time = 10 ms) {
  input[2] x: int
  output z: int

  reaction(x) -> z {=
    lf_sleep(self->processingDelay);
    bool synced = false;
    if (x[0]->is_present && x[1]->is_present) {
       synced = true;
       printf("---- SYNC'ED ----\n");
    }
    if (x[0]->is_present) {
        printf(">>> camera frame: %d\n", x[0]->value);
    }
    if (x[1]->is_present) {
        printf(">>>> lidar frame: %d\n", x[1]->value);
    }
    if (synced) {
        printf("-----------------\n");
    }
    srand(x[0]->value);
    int r = rand();
    if (r % 2) {
        lf_set(z, r % 100);
    }
  =}
}

@label("ASIL D")
reactor Brakes extends Actuator {
}

@label("QM")
reactor Display extends Actuator {
}

reactor Actuator(name: char* = "actuator", maxLag: time = 150 ms) {
  input inp: int
  state misses: int = 0
  state stp_violations: int = 0

  reaction(inp) {=
    interval_t diff_us = (lf_time_physical_elapsed() - lf_time_logical_elapsed()) / 1000;
    printf("(%s lagging physical time by %lld us)\n", self->name, diff_us);
  =} deadline(maxLag) {=
    self->misses++;
    printf("---- DEADLINE MISS ----\n");
    interval_t diff_us = (lf_time_physical_elapsed() - lf_time_logical_elapsed()) / 1000;
    printf("(%s lagging physical time by %lld us)\n", self->name, diff_us);
    printf("---- DEADLINE MISS ----\n");
  =}

  reaction(shutdown) {=
    printf("---- Deadline misses at %s: %d\n", self->name, self->misses);
    printf("---- Out-of-order events at %s: %d\n", self->name, self->stp_violations);
  =}
}

federated reactor(physicalDelay: time = 30 ms, logicalDelay: time = 50 ms) {
  // Note: if period of the sensor is smaller than the processing time,
  // then lag will grow without bound, and all deadlines will be missed!
  // The logical delay (effectively a LET), should be greater than the
  // processing time + the delay incurred by message relay.
  // The end-to-end physical time delay between sensor and actuator then
  // will be equal to the logicalDelay. Practically, logicalDelay is a
  // lower bound on the delay, and logicalDelay + maxLag (used to specify
  // the deadline in the brakes) is an upper bound on the delay.
  // A violation of the upper bound is a deadline miss.
  sensor1 = new Sensor(period = 40 ms)
  lidar = new Sensor(period = 200 ms)  // 5hz
  processor = new Processor(processingDelay=physicalDelay)
  ivi = new Display(name="display")
  sensor1.y, lidar.y -> processor.x
  processor.z -> ivi.inp after logicalDelay
  brakes = new Brakes(name="brakes", maxLag = 30 ms)
  processor.z -> brakes.inp after logicalDelay
}
