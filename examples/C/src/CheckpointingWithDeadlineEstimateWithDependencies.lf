// For fault tolerance, retry the task. However, does not retry the total task, retries from the last failed subtask.
// User divides the total task into subtasks. If the subtask success, return 0, else, return the task number.
// Even if some tasks success, but misses the deadline, reports deadline violation.
target C {
  timeout: 5 sec
}

preamble {=
  #include <stdlib.h> // rand()
  #include "platform.h" // lf_sleep()
=}

reactor Startup {
  output out: int

  reaction(startup) -> out {=
    srand(time(NULL));
    lf_set(out, 0);
  =}
}

reactor Retry(threshold: time = 2000 msec) {
  preamble {=
    #define TASK1_SLEEP_MSEC  200
    #define TASK2_SLEEP_MSEC  200
    #define TASK3_SLEEP_MSEC  200

    // Temporary lookup table...
    static const int TASK_SLEEP_TIMES[] = {
      0, // Index 0 is unused
      TASK1_SLEEP_MSEC + TASK2_SLEEP_MSEC + TASK3_SLEEP_MSEC, // For a->value == 1
      TASK2_SLEEP_MSEC + TASK3_SLEEP_MSEC, // For a->value == 2
      TASK3_SLEEP_MSEC // For a->value == 3
    };

    int task1() {
      lf_sleep(MSEC(TASK1_SLEEP_MSEC));
      if (rand() % 10 < 8) {  // 80% chance
        return 1;
      }
      return 0;
    }
    int task2() {
      lf_sleep(MSEC(TASK2_SLEEP_MSEC));
      if (rand() % 10 < 8) {  // 80% chance
        return 2;
      }
      return 0;
    }
    // Miss deadline, but return success.
    int task3() {
      lf_sleep(MSEC(TASK3_SLEEP_MSEC));
      if (rand() % 10 < 8) {  // 80% chance
        lf_sleep(MSEC(TASK3_SLEEP_MSEC));
      }
      return 0;
    }
    int total_task(int checkpoint) {
      int ret = -1;
      if (checkpoint <= 1) {  // Start from task1 if no checkpoint
        ret = task1();
        if (ret != 0) {
          return ret; // Return failure checkpoint
        }
      }

      if (checkpoint <= 2) {  // Start from task2 if the previous step succeeded
        ret = task2();
        if (ret != 0){
          return ret; // Return failure checkpoint
        }
      }
      if (checkpoint <= 3) {  // Start from task2 if the previous step succeeded
        ret = task3();
        if (ret != 0){
          return ret; // Return failure checkpoint
        }
      }
      return 0;
    }
  =}

  input in: int
  output out: int
  logical action a: int

  reaction(in) -> a {=
    lf_schedule_int (a, 0, 1);
  =}

  reaction(a) -> out {=
    // Check if available to finish on time.
    int64_t remaining_minimum_time;
    remaining_minimum_time = MSEC(TASK_SLEEP_TIMES[a->value]);

    // If the passed (physical time + remaining minimum execution time) exceeds the deadline, do not execute anymore.
    int64_t estimated_minimum_elapsed_time = lf_time_physical_elapsed() - lf_time_logical_elapsed() + remaining_minimum_time;
    if (estimated_minimum_elapsed_time > self->threshold) {
      lf_print("Estimated deadline violation detected on Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
      lf_print("The estimated minimum elapsed time is %lld msecs, while the deadline is %lld msecs.\n", estimated_minimum_elapsed_time / MSEC(1), self->threshold / MSEC(1));
      exit(1);
    }

    int result = total_task(a->value);
    lf_print("Result: %d, Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs\n", result, lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
    
    // Check if deadline violated. However, will already exit when the estimated time goes over.
    lf_check_deadline(self, true);

    if (result == 0) {
      // lf_set(out, 0);
      exit(1);
    } else {
      // lf_schedule_int(a, MSEC(100), result);
      lf_schedule_int(a, 0, result);
    }
  =} deadline(threshold) {=
    // lf_schedule(a, MSEC(10));
    lf_print("Deadline violation detected on Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs\n", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
    // lf_set(out, 0);
    exit(1);
  =}
}

main reactor {
  s = new Startup()
  c = new Retry()
  s.out -> c.in  // c.out-> c.in
}
