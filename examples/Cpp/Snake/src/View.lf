target Cpp

public preamble {=
  #include "snake.hh"
=}

reactor NcursesThreadView(size: unsigned = 32) {
  public preamble {=
    #include <ncurses.h>
  =}

  // These variables are used to send updates to the view handler thread
  state new_board: {= reactor::ImmutableValuePtr<Board> =}
  state mutex: std::mutex
  state terminate: std::atomic<bool> = false
  state score: std::atomic<unsigned> = 0

  state view_handler_thread: std::thread

  physical action key_pressed_action: int
  output key_pressed: int
  input draw_board: Board
  input draw_score: unsigned
  input print_final_score: unsigned

  method element_to_symbol(element: BoardElement): chtype {=
    switch(element) {
      case BoardElement::EMPTY:
        return ' ';
      case BoardElement::SNAKE_HEAD:
        return '@';
      case BoardElement::SNAKE_BODY:
        return '#';
      case BoardElement::APPLE:
        return 'o';
      case BoardElement::WALL:
        return 'X';
      case BoardElement::INVALID:
      default:
        return '?';
    }
  =}

  method init_ncurses() {=
    initscr();    // initialize the terminal
    refresh();    // refresh the terminal
    cbreak();     // dirable line buffering (all characters are received immediately when typed)
    noecho();     // don't echo characters typed by the user
    curs_set(0);  // hide thu cursor
  =}

  method init_board_window(): WINDOW* {=
    // get the size of the terminal
    std::size_t x_max, y_max;
    getmaxyx(stdscr, y_max, x_max);

    // The height as drawn by ncurses. The height is the size plus 2 to account for the boarder.
    std::size_t height = size + 2;
    // The width of the board as drawn by ncurses. We want a square board, but characters in the
    // terminal are rectangular (not as wide as high). Therefore, we multiply the width by 2 and
    // two charecter positions to display one element of the board. We also add 1 to account for
    // the boarder (We can use only 1 here, as we have two characters per field, but we only
    // need one in the right most field).
    std::size_t width = size * 2 + 1;

    // determine the center position
    std::size_t x_pos = (x_max - width) / 2;
    std::size_t y_pos = (y_max - height) / 2;

    // create the board and draw a frame around it
    WINDOW* board_win = newwin(size + 2, size * 2 + 1, y_pos, x_pos);
    box(board_win, 0, 0);
    wrefresh(board_win);
    // Enable keypad input (allows to directly read the arrow keys) and set the timeout for
    // reading charaters to 5 ms.
    wtimeout(board_win, 5);
    keypad(board_win, TRUE);

    return board_win;
  =}

  method init_score_window(board_win: WINDOW*): WINDOW* {=
    std::size_t x_board, y_board;
    getbegyx(board_win, y_board, x_board);
    // create the score window
    return newwin(1, size * 2 + 1, y_board + size + 3, x_board);
  =}

  method view_handler(key_pressed: {=
    reactor::PhysicalAction<int>*
  =}) {=
    init_ncurses();

    WINDOW* board_win = init_board_window();
    WINDOW* score_win = init_score_window(board_win);

    while(!terminate.load()) {
      // Read a charcter. This is a blocking call, but it times out after 5 ms returning ERR if no
      // key was pressed.
      int ch = wgetch(board_win);
      if (ch != ERR) {
        key_pressed->schedule(ch);
      }
      {
        // redraw the board if needed
        std::lock_guard<std::mutex> guard(mutex);
        if (new_board != nullptr) {
          for (int x{0}; x < static_cast<int>(size); x++) {
            for (int y{0}; y < static_cast<int>(size); y++) {
              chtype symbol = element_to_symbol(new_board->at(x, y));
              mvwaddch(board_win, y+1, x*2+1, symbol);
            }
          }
          new_board = nullptr;
          wrefresh(board_win);

          // also update the score
          mvwprintw(score_win, 0, 0, "Score: %6u", score.load());
          wrefresh(score_win);
        }
      }
    }

    endwin(); // suspend the ncurses session
  =}

  reaction init(startup) -> key_pressed_action {=
    view_handler_thread = std::thread{
      [this, &key_pressed_action](){ view_handler(&key_pressed_action);}
    };
  =}

  reaction(key_pressed_action) -> key_pressed {=
    key_pressed.set(key_pressed_action.get());
  =}

  reaction(draw_board) {=
    std::lock_guard<std::mutex> guard(mutex);
    new_board = std::move(draw_board.get());
  =}

  reaction(draw_score) {=
    score.store(*draw_score.get());
  =}

  reaction cleanup(shutdown) print_final_score {=
    terminate.store(true);
    view_handler_thread.join();
    std::cout << "Game Over! Your score: " << *print_final_score.get() << std::endl;
  =}
}
