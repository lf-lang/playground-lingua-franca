target Cpp {
  cmake-include: "snake.cmake"
}

public preamble {=
  enum class Direction {
    UP = -1,
    DOWN = 1,
    RIGHT = -2,
    LEFT = 2
  };

  enum class BoardElement {
    EMPTY,
    SNAKE_BODY,
    SNAKE_HEAD,
    APPLE,
    WALL,
    INVALID,
  };

  class Board {
   private:
    unsigned size;
    std::vector<BoardElement> elements;

   public:
    Board(unsigned size)
      : size{size}
      , elements{size * size, BoardElement::EMPTY} {}

    auto get_size() const { return size; }
    
    auto is_valid(int x, int y) const -> bool { 
      return x >= 0 && y >= 0 && x < static_cast<int>(size) && y < static_cast<int>(size); 
    }

    auto at(int x, int y) const -> BoardElement { 
      if (is_valid(x, y)) {
        return elements[y * size + x];
      }
      return BoardElement::INVALID;
    }

    void set(int x, int y, BoardElement element) {
      if (is_valid(x, y)) {
        elements[y * size + x] = element;
      }
    }
  };
=}

reactor MainView(size: unsigned = 32) {
  public preamble {=
    #include <ncurses.h>
  =}

  // These variables are used to send updates to the view handler thread
  state new_board: {= reactor::ImmutableValuePtr<Board> =}
  state mutex: std::mutex
  state terminate: std::atomic<bool> = false
  state score: std::atomic<unsigned> = 0

  state view_handler_thread: std::thread

  physical action key_pressed_action: int
  output key_pressed: int
  input draw_board: Board
  input draw_score: unsigned
  input print_final_score: unsigned

  method element_to_symbol(element: BoardElement): chtype {=
    switch(element) {
      case BoardElement::EMPTY:
        return ' ';
      case BoardElement::SNAKE_HEAD:
        return '@';
      case BoardElement::SNAKE_BODY: 
        return '#';
      case BoardElement::APPLE:
        return 'o';
      case BoardElement::WALL:
        return 'X';
      case BoardElement::INVALID:
      default:
        return '?';
    }
  =}

  method init_ncurses() {=
    initscr();    // initialize the terminal
    refresh();    // refresh the terminal
    cbreak();     // dirable line buffering (all characters are received immediately when typed)
    noecho();     // don't echo characters typed by the user
    curs_set(0);  // hide thu cursor
  =}

  method init_board_window(): WINDOW* {=
    // get the size of the terminal
    std::size_t x_max, y_max;
    getmaxyx(stdscr, y_max, x_max);

    // The height as drawn by ncurses. The height is the size plus 2 to account for the boarder.
    std::size_t height = size + 2;
    // The width of the board as drawn by ncurses. We want a square board, but characters in the 
    // terminal are rectangular (not as wide as high). Therefore, we multiply the width by 2 and
    // two charecter positions to display one element of the board. We also add 1 to account for
    // the boarder (We can use only 1 here, as we have two characters per field, but we only 
    // need one in the right most field).
    std::size_t width = size * 2 + 1;
  
    // determine the center position
    std::size_t x_pos = (x_max - width) / 2;
    std::size_t y_pos = (y_max - height) / 2;
    
    // create the board and draw a frame around it
    WINDOW* board_win = newwin(size + 2, size * 2 + 1, y_pos, x_pos);
    box(board_win, 0, 0);
    wrefresh(board_win);
    // Enable keypad input (allows to directly read the arrow keys) and set the timeout for 
    // reading charaters to 5 ms.
    wtimeout(board_win, 5);
    keypad(board_win, TRUE);

    return board_win;
  =}

  method init_score_window(board_win: WINDOW*): WINDOW* {=
    std::size_t x_board, y_board;
    getbegyx(board_win, y_board, x_board);
    // create the score window
    return newwin(1, size * 2 + 1, y_board + size + 3, x_board);
  =}

  method view_handler(key_pressed: {=
    reactor::PhysicalAction<int>*
  =}) {=
    init_ncurses();
 
    WINDOW* board_win = init_board_window();
    WINDOW* score_win = init_score_window(board_win);

    while(!terminate.load()) {
      // Read a charcter. This is a blocking call, but it times out after 5 ms returning ERR if no
      // key was pressed.
      int ch = wgetch(board_win);
      if (ch != ERR) {
        key_pressed->schedule(ch);
      }
      {
        // redraw the board if needed
        std::lock_guard<std::mutex> guard(mutex);
        if (new_board != nullptr) {
          for (int x{0}; x < static_cast<int>(size); x++) {
            for (int y{0}; y < static_cast<int>(size); y++) {
              chtype symbol = element_to_symbol(new_board->at(x, y));
              mvwaddch(board_win, y+1, x*2+1, symbol);
            }
          }
          new_board = nullptr;
          wrefresh(board_win);

          // also update the score
          mvwprintw(score_win, 0, 0, "Score: %6u", score.load());
          wrefresh(score_win);
        }
      }
    }

    endwin(); // suspend the ncurses session
  =}

  reaction init(startup) -> key_pressed_action {=
    view_handler_thread = std::thread{
      [this, &key_pressed_action](){ view_handler(&key_pressed_action);}
    };
  =}

  reaction(key_pressed_action) -> key_pressed {=
    key_pressed.set(key_pressed_action.get());
  =}

  reaction(draw_board) {=
    std::lock_guard<std::mutex> guard(mutex);
    new_board = std::move(draw_board.get());
  =}

  reaction(draw_score) {=
    score.store(*draw_score.get());
  =}

  reaction cleanup(shutdown) print_final_score {=
    terminate.store(true);
    view_handler_thread.join();
    std::cout << "Game Over! Your score: " << *print_final_score.get() << std::endl;
  =}
}

reactor SnakeModel {
  public preamble {=
    #include <deque>
  =}

  input update_direction: Direction
  input move: Board
  output updated_board: Board
  output ate_apple: void
  output invalid_move: void

  state direction: Direction = {= Direction::RIGHT =}
  state elements: std::deque<std::pair<unsigned, unsigned>>{{-1, 0}, {-2, 0}, {-3, 0}}

  reaction(update_direction) {=
    auto new_direction = *update_direction.get();
        // This checks if the new direction is not the opposit of the current direction
        if (static_cast<int>(direction) + static_cast<int>(new_direction) != 0) {
          direction = new_direction;
        }
  =}

  reaction(move) -> updated_board, ate_apple, invalid_move {= 
    Board board = *move.get();
    auto head_pos = next_head_pos();
    auto element_at_head = board.at(head_pos.first, head_pos.second);

    if (element_at_head != BoardElement::EMPTY && element_at_head != BoardElement::APPLE) {
      invalid_move.set();
    }
  
    // set the old head position to snake body
    board.set(elements.front().first, elements.front().second, BoardElement::SNAKE_BODY);
    // add new head and place it on the board
    elements.push_front(head_pos);
    board.set(head_pos.first, head_pos.second, BoardElement::SNAKE_HEAD);
    if (element_at_head != BoardElement::APPLE) {
       // remove the old tail
       board.set(elements.back().first, elements.back().second, BoardElement::EMPTY);
       elements.pop_back();
    } else {
      ate_apple.set();
    }
   
    // send the updated board back
    updated_board.set(std::move(board));
  =}

  method next_head_pos(): {=std::pair<int, int>=} {=
    int pos_x = elements.front().first;
    int pos_y = elements.front().second;
    switch(direction) {
      case Direction::UP:
        pos_y--;
        break;
      case Direction::DOWN:
        pos_y++;
        break;
      case Direction::RIGHT:
        pos_x++;
        break;
      case Direction::LEFT:
        pos_x--;
        break;
    }
    return std::make_pair(pos_x, pos_y);

  =}
}

reactor AppleModel(size: unsigned = 32) {
  public preamble {=
    #include <random>
  =}

  input add_apple: Board
  output updated_board: Board

  state rand: std::mt19937({=std::chrono::system_clock::now().time_since_epoch().count()=})
  state dist: std::uniform_int_distribution<int>(0, {=size - 1=});

  reaction(add_apple) -> updated_board {=
    Board board = *add_apple.get();
    int pos_x{-1}, pos_y{-1};
    while (board.at(pos_x, pos_y) != BoardElement::EMPTY) {
      pos_x = dist(rand);
      pos_y = dist(rand);
    }
    board.set(pos_x, pos_y, BoardElement::APPLE);
    updated_board.set(std::move(board));
  =}
}

reactor SnakeController(size: unsigned = 32, initial_interval = 500 ms) {
  output move_snake: Board
  output draw_board: Board
  input updated_board_from_snake: Board
  input updated_board_from_apple: Board
  input ate_apple: void

  logical action next_move: void

  state interval: time = initial_interval
  state current_board: Board{size}
  state apple_count: unsigned = 0

  reaction(startup, next_move) -> next_move, move_snake {= 
    move_snake.set(std::move(current_board)); 
    next_move.schedule(interval);
  =}

  reaction(updated_board_from_snake) -> draw_board {=
    current_board = std::move(*updated_board_from_snake.get());
    draw_board.set(current_board);
  =}

  reaction(updated_board_from_apple) -> draw_board {=
    current_board = std::move(*updated_board_from_apple.get());
    draw_board.set(current_board);
  =}

  reaction(ate_apple) {=
    apple_count++;
    if (apple_count % 5 == 0) {
      interval = std::chrono::duration_cast<reactor::Duration>(interval * 0.8);
    }
  =}
}

reactor KeyController {
  private preamble {=
    #include <ncurses.h>
  =}

  input key_pressed: int
  output update_direction: Direction
  output quit: void

  reaction handle_user_input(key_pressed) -> update_direction, quit {=
    switch(*key_pressed.get()) {
      case KEY_UP:
      case 'w':
        update_direction.set(Direction::UP);
        break;
      case KEY_DOWN:
      case 's':
        update_direction.set(Direction::DOWN);
        break;
      case KEY_RIGHT:
      case 'd':
        update_direction.set(Direction::RIGHT);
        break;
      case KEY_LEFT:
      case 'a':
        update_direction.set(Direction::LEFT);
        break;
      case 'q':
        quit.set();
        break;
      default:
        break;
    }
  =}
}

reactor AppleController {
  input board_from_snake: Board
  input ate_apple: void
  output add_apple: Board

  reaction(startup, ate_apple) board_from_snake -> add_apple {=
    add_apple.set(std::move(board_from_snake.get()));
  =}
}

reactor ScoreController {
  input game_over: void
  input quit: void
  input increment_score: void
  output draw_score: unsigned
  output print_final_score: unsigned

  state score: unsigned = 0

  reaction(quit, game_over) {=
    environment()->sync_shutdown();
  =}

  reaction(increment_score) -> draw_score {=
    score += 10;
    draw_score.set(score);
  =}

  reaction(shutdown) -> print_final_score {= 
    print_final_score.set(score);
  =}
}

main reactor(size: unsigned = 20, initial_interval: time = 300 ms) {
  snake_model = new SnakeModel()
  apple_model = new AppleModel(size = size)
  snake_controller = new SnakeController(size = size, initial_interval=initial_interval)
  apple_controller = new AppleController()
  score_controller = new ScoreController()
  key_controller = new KeyController()
  view = new MainView(size = size)

  snake_controller.move_snake -> snake_model.move
  snake_controller.draw_board -> view.draw_board

  apple_controller.add_apple -> apple_model.add_apple

  score_controller.print_final_score -> view.print_final_score
  score_controller.draw_score -> view.draw_score

  snake_model.updated_board -> snake_controller.updated_board_from_snake
  snake_model.invalid_move -> score_controller.game_over
  (snake_model.ate_apple)+ -> apple_controller.ate_apple, score_controller.increment_score, snake_controller.ate_apple
  snake_model.updated_board -> apple_controller.board_from_snake

  apple_model.updated_board -> snake_controller.updated_board_from_apple

  view.key_pressed -> key_controller.key_pressed
  key_controller.update_direction -> snake_model.update_direction
  key_controller.quit -> score_controller.quit
}
