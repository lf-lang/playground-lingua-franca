/**
 * Example of sensor fusion in the automotive field. An automatic emergency braking ADAS system
 * receives data from two sensors, a lidar and a radar. Their behavior is approximated
 * so that they both measure the distance from the car to the closest object in their detection range.
 * The lidar sensor has a higher sampling rate, but its functionality is affected by wheather
 * conditions (e.g., rain, fog). The radar is less susceptible to external conditions, but it has
 * a lower sampling rate.
 * The automatic emergency braking system, when one of the two sensors detects an obstacle at a
 * distance from the car below a certain configurable threshold, signals the braking system to brake the car.
 * Each sensor reactor continuously produces a distance value that is above the threshold. After a certain
 * number of activations, it sends as output a distance value below the threshold to trigger the automatic
 * emergency braking system. This number of activations is randomly initialized at startup time, and
 * the initialization is different for the two sensors, so that we do not know ahead of time which sensor
 * will detect the obstacle first.
 * The example is proposed as a federated application with the reactor-uc runtime. The STA (or maxwait)
 * of the automatic emergency braking federate is handled dynamically knowing the sampling rate
 * of both sensor: when the federate is expected to receive both inputs, the STA is set to forever;
 * when only the lidar provides data at a given tag, the STA is set to 0 to avoid unnecessary waiting time.
*/
target uC {
  platform: Native,
  // cores: 1,
  thread-policy: "rt-fifo",
  // timeout: 5s,
  // logging: debug
};

preamble {=
  #define __USE_GNU
  #include <sys/time.h>
  #include <sys/resource.h>
  #include "reactor-uc/reactor-c.h"

  instant_t get_thread_current_time_us();
=}

reactor DeadlineCheck(dline: time = 50ms) {
  input in_signal: float
  output out_signal: float

  reaction(in_signal) -> out_signal {=
    printf(PRINTF_TIME "ms deadline check started at " PRINTF_TIME "ms\n", self->dline / 1000000, lf_time_physical_elapsed() / 1000000);
    lf_set(out_signal, in_signal->value);
    printf(PRINTF_TIME "ms deadline check completed at " PRINTF_TIME "ms\n", self->dline / 1000000, lf_time_physical_elapsed() / 1000000);
  =} deadline (dline) {=
    printf(PRINTF_TIME "ms sensor deadline violated\n", self->dline / 1000000);
  =}
}

reactor Lidar(exec_time: time = 5ms) {
  preamble {=
    instant_t get_thread_current_time_us() {
      struct rusage ru;
      struct timeval t_usr;
      struct timeval t_sys;
      getrusage(RUSAGE_THREAD,&ru);
      t_usr = ru.ru_utime;
      // needed because the reaction continuously invokes
      // lf_time_physical_elapsed that ends up making a syscall
      t_sys = ru.ru_stime;
      return (instant_t) (t_usr.tv_sec*1000000 + t_usr.tv_usec + t_sys.tv_sec*1000000 + t_sys.tv_usec);
    }
  =}
  
  timer t(0ms, 50ms)
  state n_invocs: int = 0
  output lidar_data: float

  reaction(startup) {=
    // number of invocations of the reactor before signaling an obstacle
    // doubling it because the lidar is twice as fast as the radar
    srand(time(0));
    self->n_invocs = 2 * (10 + (double)rand() / RAND_MAX * 10.0);
    printf("Lidar invocs: %d\n", self->n_invocs);
  =} deadline (50ms) {=
    ;
  =}

  reaction (t) -> lidar_data {=
    printf("Lidar sensor started at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    instant_t start_time = get_thread_current_time_us();
    while (get_thread_current_time_us() - start_time < self->exec_time / 1000) {

    }
    printf("Lidar sensor completed at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    
    // remove this to restore object detection simulation
    ++self->n_invocs;

    if (--self->n_invocs <= 0) {  
      lf_set(lidar_data, 1.0);
      lf_request_stop();
      printf("Lidar sensor shutting down at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    } else {
      lf_set(lidar_data, 100.0);
    }
  =} deadline (50ms) {=
    ;
  =}
}

reactor Radar(exec_time: time = 5ms) {
  preamble {=
    instant_t get_thread_current_time_us() {
      struct rusage ru;
      struct timeval t_usr;
      struct timeval t_sys;
      getrusage(RUSAGE_THREAD,&ru);
      t_usr = ru.ru_utime;
      // needed because the reaction continuously invokes
      // lf_time_physical_elapsed that ends up making a syscall
      t_sys = ru.ru_stime;
      return (instant_t) (t_usr.tv_sec*1000000 + t_usr.tv_usec + t_sys.tv_sec*1000000 + t_sys.tv_usec);
    }
  =}

  timer t(0ms, 100ms)
  output radar_data: float
  state n_invocs: int = 0

  reaction(startup) {=
    // number of invocations of the reactor before signaling an obstacle
    srand(time(0) + 10);
    self->n_invocs = 10 + (double)rand() / RAND_MAX * 10.0;
    printf("Radar invocs: %d\n", self->n_invocs);
  =} deadline (100ms) {=
    ;
  =}

  reaction (t) -> radar_data {=
    printf("Radar sensor started at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    instant_t start_time = get_thread_current_time_us();
    while (get_thread_current_time_us() - start_time < self->exec_time / 1000) {

    }
    printf("Radar sensor completed at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    
    // remove this to restore object detection simulation
    ++self->n_invocs;
    
    if (--self->n_invocs <= 0) {  
      lf_set(radar_data, 1.0);
      lf_request_stop();
      printf("Radar sensor shutting down at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    } else {
      lf_set(radar_data, 100.0);
    }
  =} deadline (100ms) {=
    ;
  =}
}

reactor AutomaticEmergencyBraking(dist_thld: float = 20.0) {
  input lidar_in: float
  input radar_in: float
  output brake: int

  state n_invocs: int = 0
  state fault_mode: bool = false
  state disabling_fault_mode: bool = false

  reaction (lidar_in, radar_in) -> brake {=
    printf("AEB started at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);

    // FIXME: change this when wrapping overload and aeb with a federate
    if (lf_is_present(lidar_in) && lidar_in->value >= 0 && self->fault_mode == true) {
      self->disabling_fault_mode = true;
      printf("Disabling fault mode...\n");
    }

    // FIXME: change this when wrapping overload and aeb with a federate
    if (lf_is_present(radar_in) && self->disabling_fault_mode) {
      self->n_invocs = 0;
      self->fault_mode = false;
      self->disabling_fault_mode = false;
      printf("Fault mode disabled\n");
    }

    // FIXME: remove the >=0 when overload and aeb are in the same federate
    // Because of the "else-if", some radar data might be lost when lidar sends -1 (hopefully once)
    if (lf_is_present(lidar_in) && lidar_in->value >= 0 && lidar_in->value < self->dist_thld) {
      printf("Lidar has detected close object -> signaling braking\n");
      lf_set(brake, 1);
      lf_request_stop();
      printf("AEB shutting down at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    } else if (lf_is_present(radar_in) && radar_in->value < self->dist_thld) {
      printf("Radar has detected close object -> signaling braking\n");
      lf_set(brake, 1);
      lf_request_stop();
      printf("AEB shutting down at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    }
    printf("AEB completed at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    
    self->n_invocs++;
    if (!self->fault_mode) {
      if (self->n_invocs % 2) {
        lf_set_maxwait(0);
      } else {
        lf_set_maxwait(FOREVER);
      }
    }
  =} deadline(50ms) {=
    printf("AEB deadline violated\n");
    
    // FIXME: change this when wrapping overload and aeb with a federate
    self->fault_mode = true;
    lf_set_maxwait(0);
    printf("Fault mode\n");
  =} maxwait (forever) {=
    printf("STP violation on AEB\n");
  =}
}

reactor BrakingSystem {
  input signal: int

  reaction (signal) {=
    printf("!!!!!!!!!!!!!BRAKING!!!!!!!!!!!!!\n");
    lf_request_stop();
    printf("Braking system shutting down at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
  =} deadline(50ms) {=
    printf("Brake deadline violated\n");
  =}
}

reactor OverloadMitigationSystem {
  input lidar_in: float
  output lidar_out: float
  input radar_in: float
  output radar_out: float

  state n_invocs: int = 0
  state fault_mode: bool = false
  state disabling_fault_mode: bool = false
  state correct_input_counter: int = 0

  reaction (lidar_in) -> lidar_out {=
    // passing the signal through
    if (!self->fault_mode) {
      lf_set(lidar_out, lidar_in->value);
      printf("Passing lidar\n");
    } else {
      printf("Fault mode: not passing lidar\n");
      if (++self->correct_input_counter > 10) {
        printf("Disabling fault mode...\n");
        self->disabling_fault_mode = true;
      }
    }
  =} deadline(50ms) {=
    if (!self->fault_mode) {
      // not passing the signal through
      printf("System overload detected: dropping lidar input.\n");
      self->fault_mode = true;
      self->correct_input_counter = 0;
      lf_set_maxwait(0);
      // FIXME: change this when wrapping overload and aeb with a federate
      lf_set(lidar_out, -1);
    }
  =} maxwait (forever) {=
    printf("STP violation on overload mitigation system\n");
    self->correct_input_counter = 0;
  =}

  reaction (radar_in) -> radar_out {=
    // passing the signal through
    lf_set(radar_out, radar_in->value);
    printf("Passing radar\n");

    if (self->disabling_fault_mode) {
      self->n_invocs = 0;
      self->fault_mode = false;
      self->disabling_fault_mode = false;
      printf("Fault mode disabled\n");
    }
  =} deadline(100ms) {=
    // passing the signal through anyway:
    // in case of overload, we rely on the slowest data only
    lf_set(radar_out, radar_in->value);
  =} maxwait (forever) {=
    printf("STP violation on overload mitigation system\n");
  =}

  reaction (radar_in, lidar_in) {=
    self->n_invocs++;
    if (!self->fault_mode) {
      if (self->n_invocs % 2) {
        lf_set_maxwait(0);
      } else {
        lf_set_maxwait(FOREVER);
      }
    }
  =} maxwait (forever) {=
    // I wonder if this is really needed
    printf("STP violation on overload mitigation system\n");
  =}
}

// reactor AutomaticEmergencyBrakingSystem {
//   input lidar_in: float
//   input radar_in: float
//   output brake: int

//   oload = new OverloadMitigationSystem()
//   aeb = new AutomaticEmergencyBraking()

//   lidar_in -> oload.lidar_in
//   radar_in -> oload.radar_in

//   oload.lidar_out -> aeb.lidar_in
//   oload.radar_out -> aeb.radar_in

//   aeb.brake -> brake
// }

federated reactor {
  lidar = new Lidar()
  radar = new Radar()
  oload = new OverloadMitigationSystem()
  aeb = new AutomaticEmergencyBraking()
  brake = new BrakingSystem()

  @buffer(20)
  lidar.lidar_data -> oload.lidar_in
  @buffer(10)
  radar.radar_data -> oload.radar_in

  @buffer(20)
  oload.lidar_out -> aeb.lidar_in
  @buffer(10)
  oload.radar_out -> aeb.radar_in

  aeb.brake -> brake.signal
}
