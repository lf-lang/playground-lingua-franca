/**
 * Example of sensor fusion in the automotive field. An automatic emergency braking ADAS system
 * receives data from two sensors, a lidar and a radar. Their behavior is approximated
 * so that they both measure the distance from the car to the closest object in their detection range.
 * The lidar sensor has a higher sampling rate, but its functionality is affected by wheather
 * conditions (e.g., rain, fog). The radar is less susceptible to external conditions, but it has
 * a lower sampling rate.
 * The automatic emergency braking system, when one of the two sensors detects an obstacle at a
 * distance from the car below a certain configurable threshold, signals the braking system to brake the car.
 * Each sensor reactor continuously produces a distance value that is above the threshold. After a certain
 * number of activations, it sends as output a distance value below the threshold to trigger the automatic
 * emergency braking system. This number of activations is randomly initialized at startup time, and
 * the initialization is different for the two sensors, so that we do not know ahead of time which sensor
 * will detect the obstacle first.
 * The example is proposed as a federated application with the reactor-uc runtime. The STA (or maxwait)
 * of the automatic emergency braking federate is handled dynamically knowing the sampling rate
 * of both sensor: when the federate is expected to receive both inputs, the STA is set to forever;
 * when only the lidar provides data at a given tag, the STA is set to 0 to avoid unnecessary waiting time.
*/
target uC {
  platform: Native,
  cores: 1,
  thread-policy: "rt-fifo",
};

preamble {=
  #define __USE_GNU
  #include <sys/time.h>
  #include <sys/resource.h>
  #include "reactor-uc/reactor-c.h"

  instant_t get_thread_current_time_us();
=}

reactor LidarSensor(exec_time: time = 5ms) {
  timer t(0ms, 50ms)
  output data: float
  state n_invocs: int = 0

  reaction(startup) {=
    // number of invocations of the reactor before signaling an obstacle
    // doubling it because the lidar is twice as fast as the radar
    srand(time(0));
    self->n_invocs = 2 * (10 + (double)rand() / RAND_MAX * 10.0);
    printf("Lidar invocs: %d\n", self->n_invocs);
  =}

  reaction (t) -> data {=
    printf("Lidar sensor started at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    instant_t start_time = get_thread_current_time_us();
    while (get_thread_current_time_us() - start_time < self->exec_time / 1000) {

    }
    printf("Lidar sensor completed at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    
    if (--self->n_invocs <= 0) {  
      lf_set(data, 1.0);
      lf_request_stop();
      printf("Lidar sensor shutting down at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    } else {
      lf_set(data, 100.0);
    }
  =} deadline (50ms) {=
    ;
  =}
}

reactor DeadlineCheck(dline: time = 50ms) {
  input in_signal: float
  output out_signal: float

  reaction(in_signal) -> out_signal {=
    printf(PRINTF_TIME "ms deadline check started at " PRINTF_TIME "ms\n", self->dline / 1000000, lf_time_physical_elapsed() / 1000000);
    lf_set(out_signal, in_signal->value);
    printf(PRINTF_TIME "ms deadline check completed at " PRINTF_TIME "ms\n", self->dline / 1000000, lf_time_physical_elapsed() / 1000000);
  =} deadline (dline) {=
    printf(PRINTF_TIME "ms sensor deadline violated\n", self->dline / 1000000);
  =}
}

reactor Lidar {
  preamble {=
    instant_t get_thread_current_time_us() {
      struct rusage ru;
      struct timeval t_usr;
      struct timeval t_sys;
      getrusage(RUSAGE_THREAD,&ru);
      t_usr = ru.ru_utime;
      // needed because the reaction continuously invokes
      // lf_time_physical_elapsed that ends up making a syscall
      t_sys = ru.ru_stime;
      return (instant_t) (t_usr.tv_sec*1000000 + t_usr.tv_usec + t_sys.tv_sec*1000000 + t_sys.tv_usec);
    }
  =}
  
  output lidar_data: float

  sensor = new LidarSensor()
  check = new DeadlineCheck(dline = 50ms)

  sensor.data -> check.in_signal
  check.out_signal -> lidar_data
}

reactor RadarSensor(exec_time: time = 5ms) {
  timer t(0ms, 100ms)
  output data: float
  state n_invocs: int = 0

  reaction(startup) {=
    // number of invocations of the reactor before signaling an obstacle
    srand(time(0) + 10);
    self->n_invocs = 10 + (double)rand() / RAND_MAX * 10.0;
    printf("Radar invocs: %d\n", self->n_invocs);
  =}

  reaction (t) -> data {=
    printf("Radar sensor started at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    instant_t start_time = get_thread_current_time_us();
    while (get_thread_current_time_us() - start_time < self->exec_time / 1000) {

    }
    printf("Radar sensor completed at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    
    if (--self->n_invocs <= 0) {  
      lf_set(data, 1.0);
      lf_request_stop();
      printf("Radar sensor shutting down at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    } else {
      lf_set(data, 100.0);
    }
  =} deadline (100ms) {=
    ;
  =}
}

reactor Radar {
  preamble {=
    instant_t get_thread_current_time_us() {
      struct rusage ru;
      struct timeval t_usr;
      struct timeval t_sys;
      getrusage(RUSAGE_THREAD,&ru);
      t_usr = ru.ru_utime;
      // needed because the reaction continuously invokes
      // lf_time_physical_elapsed that ends up making a syscall
      t_sys = ru.ru_stime;
      return (instant_t) (t_usr.tv_sec*1000000 + t_usr.tv_usec + t_sys.tv_sec*1000000 + t_sys.tv_usec);
    }
  =}

  output radar_data: float

  sensor = new RadarSensor()
  check = new DeadlineCheck(dline = 100ms)

  sensor.data -> check.in_signal
  check.out_signal -> radar_data
}

reactor AutomaticEmergencyBraking(dist_thld: float = 20.0) {
  input lidar_in: float
  input radar_in: float
  output brake: int
  state n_invocs: int = 0

  reaction (lidar_in, radar_in) -> brake {=
    printf("AEB started at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    if (lf_is_present(lidar_in) && lidar_in->value < self->dist_thld) {
      printf("Lidar has detected close object -> signaling braking\n");
      lf_set(brake, 1);
      lf_request_stop();
      printf("AEB shutting down at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    } else if (lf_is_present(radar_in) && radar_in->value < self->dist_thld) {
      printf("Radar has detected close object -> signaling braking\n");
      lf_set(brake, 1);
      lf_request_stop();
      printf("AEB shutting down at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
    }
    printf("AEB completed at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);

    self->n_invocs++;
    if (self->n_invocs % 2) {
      lf_set_maxwait(0);
    } else {
      lf_set_maxwait(FOREVER);
    }
  =} deadline(50ms) {=
    printf("AEB deadline violated\n");
  =} maxwait (forever) {=
    printf("STP violation on AEB\n");
  =}
}

reactor BrakingSystem {
  input signal: int

  reaction (signal) {=
    printf("!!!!!!!!!!!!!BRAKING!!!!!!!!!!!!!\n");
    lf_request_stop();
    printf("Braking system shutting down at " PRINTF_TIME "ms\n", lf_time_physical_elapsed() / 1000000);
  =} deadline(50ms) {=
    printf("Brake deadline violated\n");
  =}
}

federated reactor {
  lidar = new Lidar()
  radar = new Radar()
  aeb = new AutomaticEmergencyBraking()
  brake = new BrakingSystem()

  lidar.lidar_data -> aeb.lidar_in
  radar.radar_data -> aeb.radar_in
  aeb.brake -> brake.signal
}
